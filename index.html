<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pelada Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#0F9D58', // Verde Futebol
                        secondary: '#0C8048', // Verde Escuro
                        success: '#10B981',
                        danger: '#EF4444',
                        warning: '#F59E0B',
                        light: {
                            primary: '#FFFFFF',
                            secondary: '#F3F4F6',
                            tertiary: '#E5E7EB'
                        },
                        field: {
                            light: '#4CAF50', // Verde Claro (campo)
                            dark: '#388E3C',  // Verde Médio
                            line: '#FFFFFF'   // Linha do campo
                        },
                        football: {
                            black: '#333333',
                            white: '#FFFFFF'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .slide-fade-enter-active, .slide-fade-leave-active {
            transition: all 0.3s ease;
        }
        .slide-fade-enter-from, .slide-fade-leave-to {
            transform: translateY(20px);
            opacity: 0;
        }
        
        /* Input Range Styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0F9D58;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0F9D58;
            cursor: pointer;
        }

        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: rgba(156, 163, 175, 0.5);
            border-radius: 20px;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        .animate-pulse-slow {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        /* Fix para o toggle switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #0F9D58;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        /* Corrigir posição no container */
        .position-tag {
            white-space: nowrap;
            display: inline-block;
            margin-right: 2px;
        }

        /* Estilos para exportação/importação */
        .file-input {
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position: absolute;
            z-index: -1;
        }

        .file-input + label {
            cursor: pointer;
            display: inline-block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        /* Estilos para o modal */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .modal-content {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            max-width: 90%;
            width: 500px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-body {
            padding: 1rem;
            overflow-y: auto;
            max-height: 70vh;
        }
        
        .modal-footer {
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: flex-end;
        }

        /* Player Grid */
        .player-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 0.5rem;
        }
        
        .player-card {
            padding: 0.5rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .player-card:hover {
            background-color: #f3f4f6;
        }
        
        .player-card.selected {
            border-color: #0F9D58;
            background-color: #E8F5E9;
        }
        
        /* Campo de futebol background */
        .football-field-bg {
            background: linear-gradient(#4CAF50, #388E3C);
            background-size: 40px 40px;
            background-image: repeating-linear-gradient(0deg, #388E3C, #388E3C 2px, #4CAF50 2px, #4CAF50 20px);
        }
        
        .navbar-pattern {
            background-color: #0F9D58;
            background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23FFFFFF' fill-opacity='0.05' fill-rule='evenodd'%3E%3Ccircle cx='3' cy='3' r='3'/%3E%3Ccircle cx='13' cy='13' r='3'/%3E%3C/g%3E%3C/svg%3E");
        }
        
        /* Football ball style */
        .football-icon {
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.2));
        }
    </style>
</head>
<body class="font-sans bg-light-primary text-gray-800">
    <div id="app" class="min-h-screen flex flex-col">
        <!-- Navbar -->
        <nav class="navbar-pattern text-white p-4 shadow-lg">
            <div class="container mx-auto flex items-center">
                <div class="flex items-center space-x-2">
                    <i class="fas fa-futbol text-2xl football-icon"></i>
                    <h1 class="text-xl font-bold">Pelada Manager</h1>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="container mx-auto flex-grow p-4">
            <!-- Tabs Navigation -->
            <div class="flex flex-col sm:flex-row justify-center border-b border-gray-300 mb-6">
                <button class="tab-button py-3 px-6 font-medium border-b-2 border-primary text-primary" data-tab="players">
                    <i class="fas fa-users mr-2"></i>Jogadores
                </button>
                <button class="tab-button py-3 px-6 font-medium border-b-2 border-transparent hover:text-primary" data-tab="teams">
                    <i class="fas fa-random mr-2"></i>Sorteio
                </button>
                <button class="tab-button py-3 px-6 font-medium border-b-2 border-transparent hover:text-primary" data-tab="restrictions">
                    <i class="fas fa-ban mr-2"></i>Restrições
                </button>
            </div>

            <!-- Players Tab -->
            <div id="players-tab" class="tab-content">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <!-- Left Column: Player List -->
                    <div class="lg:col-span-2 bg-light-secondary rounded-lg shadow-md p-4">
                        <div class="flex flex-col md:flex-row md:items-center justify-between mb-4">
                            <h2 class="text-xl font-bold mb-2 md:mb-0">Lista de Jogadores</h2>
                            <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
                                <div class="relative">
                                    <input 
                                        type="text" 
                                        id="player-search" 
                                        placeholder="Buscar jogador..." 
                                        class="pl-10 pr-4 py-2 rounded-lg bg-white border border-gray-300 text-base focus:outline-none focus:ring-2 focus:ring-primary"
                                    >
                                    <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                                </div>
                            </div>
                        </div>

                        <!-- Player Stats -->
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4">
                            <div class="bg-white p-3 rounded-lg shadow">
                                <p class="text-gray-500 text-sm">Total</p>
                                <p class="text-2xl font-bold" id="total-players">0</p>
                            </div>
                            <div class="bg-white p-3 rounded-lg shadow">
                                <p class="text-gray-500 text-sm">Disponíveis</p>
                                <p class="text-2xl font-bold" id="available-players">0</p>
                            </div>
                            <div class="bg-white p-3 rounded-lg shadow">
                                <p class="text-gray-500 text-sm">Por Posição</p>
                                <div class="flex flex-wrap gap-1 text-sm mt-1">
                                    <span class="position-tag bg-red-100 text-red-800 px-2 rounded">
                                        ZAG: <span id="zag-count">0</span>
                                    </span>
                                    <span class="position-tag bg-green-100 text-green-800 px-2 rounded">
                                        MEI: <span id="mei-count">0</span>
                                    </span>
                                    <span class="position-tag bg-blue-100 text-blue-800 px-2 rounded">
                                        ATA: <span id="ata-count">0</span>
                                    </span>
                                </div>
                            </div>
                            <div class="bg-white p-3 rounded-lg shadow">
                                <p class="text-gray-500 text-sm">Média Técnica</p>
                                <p class="text-2xl font-bold" id="avg-level">0.0</p>
                            </div>
                        </div>

                        <!-- Import/Export Buttons -->
                        <div class="flex flex-wrap gap-2 mb-4">
                            <button id="export-players-btn" class="px-4 py-2 bg-primary hover:bg-secondary text-white font-medium rounded-lg transition-colors">
                                <i class="fas fa-file-export mr-2"></i>Exportar Jogadores
                            </button>
                            
                            <div class="relative overflow-hidden">
                                <input type="file" id="import-players-input" class="file-input" accept=".json">
                                <label for="import-players-input" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg transition-colors">
                                    <i class="fas fa-file-import mr-2"></i>Importar Jogadores
                                </label>
                            </div>
                        </div>

                        <!-- Player Table -->
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white shadow-md rounded-lg overflow-hidden">
                                <thead class="bg-gray-100 border-b">
                                    <tr>
                                        <th class="py-3 px-4 text-left">Nome</th>
                                        <th class="py-3 px-4 text-left">Posição</th>
                                        <th class="py-3 px-4 text-left">Nível</th>
                                        <th class="py-3 px-4 text-left">Disponível</th>
                                        <th class="py-3 px-4 text-left">Ações</th>
                                    </tr>
                                </thead>
                                <tbody id="player-table-body">
                                    <!-- Players will be added here -->
                                    <tr>
                                        <td colspan="5" class="py-4 px-4 text-center text-gray-500">
                                            Nenhum jogador cadastrado.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Right Column: Add/Edit Player Form -->
                    <div class="bg-light-secondary rounded-lg shadow-md p-4">
                        <h2 class="text-xl font-bold mb-4" id="form-title">Adicionar Jogador</h2>
                        <form id="player-form" class="space-y-4">
                            <input type="hidden" id="player-id" value="">

                            <div>
                                <label for="player-name" class="block mb-1 font-medium">Nome *</label>
                                <input 
                                    type="text" 
                                    id="player-name" 
                                    required 
                                    class="w-full px-4 py-2 rounded-lg border border-gray-300 bg-white text-base focus:outline-none focus:ring-2 focus:ring-primary"
                                    placeholder="Nome do jogador"
                                >
                            </div>

                            <div>
                                <label for="player-position" class="block mb-1 font-medium">Posição *</label>
                                <select 
                                    id="player-position" 
                                    required 
                                    class="w-full px-4 py-2 rounded-lg border border-gray-300 bg-white text-base focus:outline-none focus:ring-2 focus:ring-primary"
                                >
                                    <option value="">Selecione a posição</option>
                                    <option value="ZAG">Zagueiro (ZAG)</option>
                                    <option value="MEI">Meio-campo (MEI)</option>
                                    <option value="ATA">Atacante (ATA)</option>
                                </select>
                            </div>

                            <div>
                                <label for="player-level" class="block mb-1 font-medium">
                                    Nível Técnico: <span id="level-value">3.0</span>
                                </label>
                                <input 
                                    type="range" 
                                    id="player-level" 
                                    min="0.5" 
                                    max="5.0" 
                                    step="0.5" 
                                    value="3.0" 
                                    class="w-full"
                                >
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>0.5</span>
                                    <span>5.0</span>
                                </div>
                            </div>

                            <div class="flex items-center">
                                <input 
                                    type="checkbox" 
                                    id="player-available" 
                                    checked 
                                    class="w-5 h-5 text-primary"
                                >
                                <label for="player-available" class="ml-2 font-medium">
                                    Disponível para sorteio
                                </label>
                            </div>

                            <div class="flex space-x-2">
                                <button 
                                    type="submit" 
                                    class="px-4 py-2 bg-primary hover:bg-secondary text-white font-medium rounded-lg transition-colors w-full"
                                >
                                    <i class="fas fa-save mr-2"></i>Salvar
                                </button>
                                <button 
                                    type="button" 
                                    id="cancel-button" 
                                    class="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white font-medium rounded-lg transition-colors w-full hidden"
                                >
                                    <i class="fas fa-times mr-2"></i>Cancelar
                                </button>
                            </div>
                        </form>

                        <hr class="my-6 border-gray-300">

                        <div class="space-y-4">
                            <h3 class="font-bold text-lg">Ações Rápidas</h3>
                            <div class="flex flex-col space-y-2">
                                <button 
                                    id="toggle-all-btn" 
                                    class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-colors"
                                >
                                    <i class="fas fa-toggle-on mr-2"></i>Todos Disponíveis
                                </button>
                                <button 
                                    id="clear-all-btn" 
                                    class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-medium rounded-lg transition-colors"
                                >
                                    <i class="fas fa-trash-alt mr-2"></i>Limpar Todos
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Restrictions Tab -->
            <div id="restrictions-tab" class="tab-content hidden">
                <div class="bg-light-secondary rounded-lg shadow-md p-6">
                    <h2 class="text-xl font-bold mb-4">Restrições de Jogadores</h2>
                    <p class="text-gray-600 mb-6">
                        Adicione restrições para jogadores que não podem jogar no mesmo time. Estes jogadores nunca serão sorteados para o mesmo time.
                    </p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- Left: Add New Restriction -->
                        <div class="bg-white p-4 rounded-lg shadow">
                            <h3 class="font-bold text-lg mb-4">Adicionar Nova Restrição</h3>
                            <form id="restriction-form" class="space-y-4">
                                <div>
                                    <label class="block mb-1 font-medium">Jogador 1</label>
                                    <select id="restriction-player1" class="w-full px-4 py-2 rounded-lg border border-gray-300 bg-white text-base focus:outline-none focus:ring-2 focus:ring-primary">
                                        <option value="">Selecione um jogador</option>
                                    </select>
                                </div>
                                
                                <div>
                                    <label class="block mb-1 font-medium">Jogador 2</label>
                                    <select id="restriction-player2" class="w-full px-4 py-2 rounded-lg border border-gray-300 bg-white text-base focus:outline-none focus:ring-2 focus:ring-primary">
                                        <option value="">Selecione um jogador</option>
                                    </select>
                                </div>
                                
                                <button 
                                    type="submit" 
                                    class="px-4 py-2 bg-primary hover:bg-secondary text-white font-medium rounded-lg transition-colors w-full"
                                >
                                    <i class="fas fa-plus mr-2"></i>Adicionar Restrição
                                </button>
                            </form>
                        </div>
                        
                        <!-- Right: Current Restrictions -->
                        <div class="bg-white p-4 rounded-lg shadow">
                            <h3 class="font-bold text-lg mb-4">Restrições Atuais</h3>
                            <div id="no-restrictions" class="text-center py-6 text-gray-500">
                                <i class="fas fa-ban text-gray-300 text-4xl mb-3"></i>
                                <p>Nenhuma restrição cadastrada.</p>
                            </div>
                            <ul id="restrictions-list" class="space-y-2 max-h-60 overflow-y-auto custom-scrollbar">
                                <!-- Restrictions will be added here -->
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Teams Tab -->
            <div id="teams-tab" class="tab-content hidden">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <!-- Left Column: Configuration -->
                    <div class="lg:col-span-1 bg-light-secondary rounded-lg shadow-md p-4">
                        <h2 class="text-xl font-bold mb-4">Configuração do Sorteio</h2>
                        <form id="teams-config-form" class="space-y-4">
                            <div>
                                <label for="players-per-team" class="block mb-1 font-medium">
                                    Jogadores por Time
                                </label>
                                <select 
                                    id="players-per-team" 
                                    class="w-full px-4 py-2 rounded-lg border border-gray-300 bg-white text-base focus:outline-none focus:ring-2 focus:ring-primary"
                                >
                                    <option value="4">4 jogadores</option>
                                    <option value="5" selected>5 jogadores</option>
                                    <option value="6">6 jogadores</option>
                                    <option value="7">7 jogadores</option>
                                </select>
                            </div>

                            <div>
                                <label for="number-of-teams" class="block mb-1 font-medium">
                                    Número de Times
                                </label>
                                <select 
                                    id="number-of-teams" 
                                    class="w-full px-4 py-2 rounded-lg border border-gray-300 bg-white text-base focus:outline-none focus:ring-2 focus:ring-primary"
                                >
                                    <option value="2" selected>2 times</option>
                                    <option value="3">3 times</option>
                                    <option value="4">4 times</option>
                                </select>
                            </div>

                            <div id="team-names-container" class="space-y-3">
                                <label class="block font-medium">Nomes dos Times</label>
                                <div class="team-name-input">
                                    <label class="text-sm text-gray-600">Time 1</label>
                                    <input 
                                        type="text" 
                                        class="team-name w-full px-4 py-2 rounded-lg border border-gray-300 bg-white text-base focus:outline-none focus:ring-2 focus:ring-primary"
                                        value="Time A"
                                        placeholder="Nome do time"
                                    >
                                </div>
                                <div class="team-name-input">
                                    <label class="text-sm text-gray-600">Time 2</label>
                                    <input 
                                        type="text" 
                                        class="team-name w-full px-4 py-2 rounded-lg border border-gray-300 bg-white text-base focus:outline-none focus:ring-2 focus:ring-primary"
                                        value="Time B"
                                        placeholder="Nome do time"
                                    >
                                </div>
                            </div>

                            <!-- Player selection buttons for star/weak -->
                            <div class="flex gap-2 mt-2">
                                <button 
                                    type="button" 
                                    id="select-stars-btn" 
                                    class="px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white font-medium rounded-lg transition-colors flex-1"
                                >
                                    <i class="fas fa-star mr-2"></i>Cabeças de Chave
                                </button>
                                <button 
                                    type="button" 
                                    id="select-weaks-btn" 
                                    class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white font-medium rounded-lg transition-colors flex-1"
                                >
                                    <i class="fas fa-arrow-down mr-2"></i>Perebas
                                </button>
                            </div>

                            <!-- Selected player counters -->
                            <div class="grid grid-cols-2 gap-2">
                                <div class="bg-yellow-100 p-2 rounded-lg text-center">
                                    <p class="text-yellow-800 text-sm">Cabeças de Chave:</p>
                                    <p class="font-bold" id="stars-count">0</p>
                                </div>
                                <div class="bg-red-100 p-2 rounded-lg text-center">
                                    <p class="text-red-800 text-sm">Perebas:</p>
                                    <p class="font-bold" id="weaks-count">0</p>
                                </div>
                            </div>

                            <div class="pt-2">
                                <button 
                                    type="button" 
                                    id="draw-teams-btn" 
                                    class="px-4 py-3 w-full bg-primary hover:bg-secondary text-white font-medium rounded-lg transition-colors flex items-center justify-center"
                                >
                                    <i class="fas fa-random mr-2"></i>Sortear Times
                                </button>
                            </div>
                        </form>

                        <div id="draw-progress" class="mt-6 hidden">
                            <h3 class="font-medium mb-2">Progresso do Sorteio</h3>
                            <div class="bg-gray-200 rounded-full h-4 mb-2">
                                <div id="progress-bar" class="bg-primary h-4 rounded-full" style="width: 0%"></div>
                            </div>
                            <p id="progress-text" class="text-sm text-gray-600">
                                Procurando equilíbrio ideal...
                            </p>
                        </div>

                        <div id="balance-indicator" class="mt-6 hidden">
                            <h3 class="font-medium mb-2">Equilíbrio dos Times</h3>
                            <div class="bg-gray-200 rounded-full h-4 mb-2">
                                <div id="balance-bar" class="bg-green-500 h-4 rounded-full" style="width: 0%"></div>
                            </div>
                            <p id="balance-text" class="text-sm text-gray-600">
                                Equilíbrio: <span id="balance-value">0%</span>
                            </p>
                            <button 
                                id="accept-balance-btn" 
                                class="mt-4 px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg transition-colors w-full hidden"
                            >
                                <i class="fas fa-check mr-2"></i>Aceitar Equilíbrio
                            </button>
                            <button 
                                id="try-again-btn" 
                                class="mt-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-colors w-full hidden"
                            >
                                <i class="fas fa-sync-alt mr-2"></i>Tentar Novamente
                            </button>
                        </div>
                    </div>

                    <!-- Right Column: Results -->
                    <div class="lg:col-span-2">
                        <div id="draw-results" class="hidden">
                            <div class="flex flex-col md:flex-row justify-between items-start mb-4">
                                <h2 class="text-xl font-bold mb-4 md:mb-0">Resultado do Sorteio</h2>
                                
                                <!-- Compartilhar Resultado -->
                                <div id="share-buttons" class="hidden flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-3">
                                    <button 
                                        id="share-draw-whatsapp" 
                                        class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg transition-colors flex items-center"
                                    >
                                        <i class="fab fa-whatsapp mr-2 text-lg"></i>Compartilhar Sorteio
                                    </button>
                                    <button 
                                        id="share-players-whatsapp" 
                                        class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-colors flex items-center"
                                    >
                                        <i class="fas fa-users mr-2"></i>Compartilhar Jogadores
                                    </button>
                                </div>
                            </div>
                            
                            <div id="teams-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <!-- Teams will be displayed here -->
                            </div>
                        </div>

                        <div id="no-draw-results" class="bg-light-secondary rounded-lg shadow-md p-8 text-center">
                            <div class="football-field-bg p-4 rounded-lg shadow-inner mb-4 relative overflow-hidden opacity-40">
                                <div class="w-full h-40 rounded-lg border-2 border-white flex items-center justify-center">
                                    <div class="w-20 h-20 rounded-full border-2 border-white flex items-center justify-center">
                                        <i class="fas fa-futbol text-4xl text-white"></i>
                                    </div>
                                </div>
                            </div>
                            
                            <h3 class="text-xl font-bold mb-2">Nenhum sorteio realizado</h3>
                            <p class="text-gray-600 mb-4">
                                Configure os parâmetros e clique em "Sortear Times" para gerar os times.
                            </p>
                            <div class="space-y-4 max-w-md mx-auto">
                                <div class="bg-white p-3 rounded-lg shadow text-left">
                                    <h4 class="font-bold text-primary mb-1">Regras de Equilíbrio:</h4>
                                    <ul class="list-disc pl-5 text-sm text-gray-600 space-y-1">
                                        <li>Cada time terá pelo menos um jogador de cada posição (ZAG, MEI, ATA), quando possível</li>
                                        <li>O nível técnico total dos times será equilibrado</li>
                                        <li>Todos os times terão o mesmo número de jogadores</li>
                                        <li>Os cabeças de chave e perebas serão equilibrados entre os times</li>
                                        <li>Restrições de jogadores serão respeitadas</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Modals -->
        <!-- Star Players Selection Modal -->
        <div id="star-players-modal" class="modal-backdrop hidden">
            <div class="modal-content">
                <div class="modal-header bg-yellow-500 text-white">
                    <h3 class="font-bold text-xl">Selecionar Cabeças de Chave</h3>
                    <button id="close-star-modal" class="text-white hover:text-gray-200">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <p class="text-gray-600 mb-4">Selecione os jogadores que serão cabeças de chave neste sorteio:</p>
                    <div id="star-players-grid" class="player-grid">
                        <!-- Available players will be inserted here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="confirm-stars" class="px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white font-medium rounded-lg transition-colors">
                        <i class="fas fa-check mr-2"></i>Confirmar
                    </button>
                </div>
            </div>
        </div>

        <!-- Weak Players Selection Modal -->
        <div id="weak-players-modal" class="modal-backdrop hidden">
            <div class="modal-content">
                <div class="modal-header bg-red-500 text-white">
                    <h3 class="font-bold text-xl">Selecionar Perebas</h3>
                    <button id="close-weak-modal" class="text-white hover:text-gray-200">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <p class="text-gray-600 mb-4">Selecione os jogadores que serão perebas neste sorteio:</p>
                    <div id="weak-players-grid" class="player-grid">
                        <!-- Available players will be inserted here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="confirm-weaks" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white font-medium rounded-lg transition-colors">
                        <i class="fas fa-check mr-2"></i>Confirmar
                    </button>
                </div>
            </div>
        </div>

        <!-- Notification Toast -->
        <div id="toast" class="fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg bg-gray-800 text-white transform translate-y-full transition-transform duration-300 flex items-center z-50">
            <span id="toast-icon" class="mr-2"><i class="fas fa-check-circle"></i></span>
            <span id="toast-message">Mensagem de notificação</span>
        </div>

        <!-- Footer -->
        <footer class="mt-auto bg-light-secondary text-center p-4 text-sm text-gray-600">
            <p>Made by Evandro Almeida &copy;</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the app
            const app = {
                players: [],
                currentId: 1,
                editingPlayer: null,
                drawnTeams: [],
                sortingInProgress: false,
                namesRevealed: false,
                playerRestrictions: [],
                selectedStars: [],
                selectedWeaks: [],
                
                // DOM Elements
                elements: {
                    // Player form elements
                    playerForm: document.getElementById('player-form'),
                    playerId: document.getElementById('player-id'),
                    playerName: document.getElementById('player-name'),
                    playerPosition: document.getElementById('player-position'),
                    playerLevel: document.getElementById('player-level'),
                    levelValue: document.getElementById('level-value'),
                    playerAvailable: document.getElementById('player-available'),
                    cancelButton: document.getElementById('cancel-button'),
                    formTitle: document.getElementById('form-title'),
                    
                    // Player list elements
                    playerTableBody: document.getElementById('player-table-body'),
                    playerSearch: document.getElementById('player-search'),
                    
                    // Stats elements
                    totalPlayers: document.getElementById('total-players'),
                    availablePlayers: document.getElementById('available-players'),
                    zagCount: document.getElementById('zag-count'),
                    meiCount: document.getElementById('mei-count'),
                    ataCount: document.getElementById('ata-count'),
                    avgLevel: document.getElementById('avg-level'),
                    
                    // Import/Export elements
                    exportPlayersBtn: document.getElementById('export-players-btn'),
                    importPlayersInput: document.getElementById('import-players-input'),
                    
                    // Quick action buttons
                    toggleAllBtn: document.getElementById('toggle-all-btn'),
                    clearAllBtn: document.getElementById('clear-all-btn'),
                    
                    // Player status selection buttons
                    selectStarsBtn: document.getElementById('select-stars-btn'),
                    selectWeaksBtn: document.getElementById('select-weaks-btn'),
                    starsCount: document.getElementById('stars-count'),
                    weaksCount: document.getElementById('weaks-count'),
                    
                    // Star Players Modal
                    starPlayersModal: document.getElementById('star-players-modal'),
                    starPlayersGrid: document.getElementById('star-players-grid'),
                    closeStarModal: document.getElementById('close-star-modal'),
                    confirmStars: document.getElementById('confirm-stars'),
                    
                    // Weak Players Modal
                    weakPlayersModal: document.getElementById('weak-players-modal'),
                    weakPlayersGrid: document.getElementById('weak-players-grid'),
                    closeWeakModal: document.getElementById('close-weak-modal'),
                    confirmWeaks: document.getElementById('confirm-weaks'),
                    
                    // Teams config elements
                    teamsConfigForm: document.getElementById('teams-config-form'),
                    playersPerTeam: document.getElementById('players-per-team'),
                    numberOfTeams: document.getElementById('number-of-teams'),
                    teamNamesContainer: document.getElementById('team-names-container'),
                    
                    // Teams draw elements
                    drawTeamsBtn: document.getElementById('draw-teams-btn'),
                    teamsContainer: document.getElementById('teams-container'),
                    drawResults: document.getElementById('draw-results'),
                    noDrawResults: document.getElementById('no-draw-results'),
                    
                    // Draw progress elements
                    drawProgress: document.getElementById('draw-progress'),
                    progressBar: document.getElementById('progress-bar'),
                    progressText: document.getElementById('progress-text'),
                    
                    // Balance indicator elements
                    balanceIndicator: document.getElementById('balance-indicator'),
                    balanceBar: document.getElementById('balance-bar'),
                    balanceText: document.getElementById('balance-text'),
                    balanceValue: document.getElementById('balance-value'),
                    acceptBalanceBtn: document.getElementById('accept-balance-btn'),
                    tryAgainBtn: document.getElementById('try-again-btn'),
                    
                    // Share elements
                    shareDrawWhatsapp: document.getElementById('share-draw-whatsapp'),
                    sharePlayersWhatsapp: document.getElementById('share-players-whatsapp'),
                    shareButtons: document.getElementById('share-buttons'),
                    
                    // Restriction elements
                    restrictionForm: document.getElementById('restriction-form'),
                    restrictionPlayer1: document.getElementById('restriction-player1'),
                    restrictionPlayer2: document.getElementById('restriction-player2'),
                    restrictionsList: document.getElementById('restrictions-list'),
                    noRestrictions: document.getElementById('no-restrictions'),
                    
                    // Tab elements
                    tabButtons: document.querySelectorAll('.tab-button'),
                    tabContents: document.querySelectorAll('.tab-content'),
                    
                    // Toast
                    toast: document.getElementById('toast'),
                    toastIcon: document.getElementById('toast-icon'),
                    toastMessage: document.getElementById('toast-message')
                },
                
                init() {
                    this.loadData();
                    this.setupEventListeners();
                    this.updateStats();
                    this.updateUI();
                    this.updatePlayerStatusCounts();
                },
                
                // Load data from localStorage
                loadData() {
                    // Load players
                    const savedPlayers = localStorage.getItem('peladaPlayers');
                    if (savedPlayers) {
                        this.players = JSON.parse(savedPlayers);
                        // Find the max ID to continue from there
                        this.currentId = this.players.reduce((max, player) => Math.max(max, player.id), 0) + 1;
                    }
                    
                    // Load restrictions
                    const savedRestrictions = localStorage.getItem('peladaRestrictions');
                    if (savedRestrictions) {
                        this.playerRestrictions = JSON.parse(savedRestrictions);
                    }
                    
                    // Initialize empty arrays for selectedStars and selectedWeaks
                    this.selectedStars = [];
                    this.selectedWeaks = [];
                },
                
                // Save players to localStorage
                savePlayers() {
                    localStorage.setItem('peladaPlayers', JSON.stringify(this.players));
                },
                
                // Save restrictions to localStorage
                saveRestrictions() {
                    localStorage.setItem('peladaRestrictions', JSON.stringify(this.playerRestrictions));
                },
                
                // Setup event listeners
                setupEventListeners() {
                    // Player level slider
                    this.elements.playerLevel.addEventListener('input', () => {
                        this.elements.levelValue.textContent = this.elements.playerLevel.value;
                    });
                    
                    // Player form
                    this.elements.playerForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.savePlayer();
                    });
                    
                    // Cancel button
                    this.elements.cancelButton.addEventListener('click', () => {
                        this.cancelEdit();
                    });
                    
                    // Player search
                    this.elements.playerSearch.addEventListener('input', () => {
                        this.filterPlayers();
                    });
                    
                    // Export players button
                    this.elements.exportPlayersBtn.addEventListener('click', () => {
                        this.exportPlayers();
                    });
                    
                    // Import players input
                    this.elements.importPlayersInput.addEventListener('change', (e) => {
                        this.importPlayers(e);
                    });
                    
                    // Quick action buttons
                    this.elements.toggleAllBtn.addEventListener('click', () => {
                        this.toggleAllPlayers();
                    });
                    
                    this.elements.clearAllBtn.addEventListener('click', () => {
                        if (confirm('Tem certeza que deseja apagar todos os jogadores? Esta ação não pode ser desfeita.')) {
                            this.clearAllPlayers();
                        }
                    });
                    
                    // Player status selection buttons
                    this.elements.selectStarsBtn.addEventListener('click', () => {
                        this.openStarPlayersModal();
                    });
                    
                    this.elements.selectWeaksBtn.addEventListener('click', () => {
                        this.openWeakPlayersModal();
                    });
                    
                    // Star modal events
                    this.elements.closeStarModal.addEventListener('click', () => {
                        this.elements.starPlayersModal.classList.add('hidden');
                    });
                    
                    this.elements.confirmStars.addEventListener('click', () => {
                        this.confirmStarPlayers();
                    });
                    
                    // Weak modal events
                    this.elements.closeWeakModal.addEventListener('click', () => {
                        this.elements.weakPlayersModal.classList.add('hidden');
                    });
                    
                    this.elements.confirmWeaks.addEventListener('click', () => {
                        this.confirmWeakPlayers();
                    });
                    
                    // Teams config
                    this.elements.numberOfTeams.addEventListener('change', () => {
                        this.updateTeamNamesInputs();
                    });
                    
                    // Draw teams
                    this.elements.drawTeamsBtn.addEventListener('click', () => {
                        this.drawTeams();
                    });
                    
                    // Accept balance
                    this.elements.acceptBalanceBtn.addEventListener('click', () => {
                        this.revealPlayerNames();
                    });
                    
                    // Try again
                    this.elements.tryAgainBtn.addEventListener('click', () => {
                        this.drawTeams();
                    });
                    
                    // Share via WhatsApp
                    this.elements.shareDrawWhatsapp.addEventListener('click', () => {
                        this.shareViaWhatsApp(this.formatDrawResultsForShare());
                    });
                    
                    this.elements.sharePlayersWhatsapp.addEventListener('click', () => {
                        this.shareViaWhatsApp(this.formatPlayersForShare());
                    });
                    
                    // Restriction form
                    this.elements.restrictionForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.addRestriction();
                    });
                    
                    // Tab navigation
                    this.elements.tabButtons.forEach(button => {
                        button.addEventListener('click', () => {
                            const tabName = button.getAttribute('data-tab');
                            this.switchTab(tabName);
                            
                            // Update restriction players if switching to restrictions tab
                            if (tabName === 'restrictions') {
                                this.updateRestrictionPlayersDropdown();
                            }
                        });
                    });
                    
                    // Click outside modals to close
                    window.addEventListener('click', (e) => {
                        if (e.target === this.elements.starPlayersModal) {
                            this.elements.starPlayersModal.classList.add('hidden');
                        }
                        if (e.target === this.elements.weakPlayersModal) {
                            this.elements.weakPlayersModal.classList.add('hidden');
                        }
                    });
                },
                
                // Open Star Players Modal
                openStarPlayersModal() {
                    // Get available players
                    const availablePlayers = this.players.filter(p => p.available);
                    
                    if (availablePlayers.length === 0) {
                        this.showToast('Nenhum jogador disponível para seleção!', 'error');
                        return;
                    }
                    
                    // Clear and populate grid
                    this.elements.starPlayersGrid.innerHTML = '';
                    
                    // Sort players by level (descending)
                    const sortedPlayers = [...availablePlayers].sort((a, b) => b.level - a.level);
                    
                    sortedPlayers.forEach(player => {
                        const isSelected = this.selectedStars.includes(player.name);
                        const isWeak = this.selectedWeaks.includes(player.name);
                        const card = document.createElement('div');
                        
                        // If the player is already a weak, it can't be a star
                        const disabledClass = isWeak ? 'opacity-50 cursor-not-allowed' : '';
                        
                        card.className = `player-card ${isSelected ? 'selected' : ''} ${disabledClass}`;
                        card.dataset.name = player.name;
                        
                        // Add position color indicator
                        let positionBg = '';
                        if (player.position === 'ZAG') positionBg = 'bg-red-100 text-red-800';
                        else if (player.position === 'MEI') positionBg = 'bg-green-100 text-green-800';
                        else if (player.position === 'ATA') positionBg = 'bg-blue-100 text-blue-800';
                        
                        card.innerHTML = `
                            <div class="w-8 h-8 rounded-full bg-primary mb-1 flex items-center justify-center text-white font-bold">
                                ${player.level}
                            </div>
                            <div class="text-sm font-medium truncate max-w-full">${player.name}</div>
                            <div class="text-xs ${positionBg} px-2 py-0.5 rounded mt-1">${player.position}</div>
                        `;
                        
                        // Only add click event if not disabled
                        if (!isWeak) {
                            card.addEventListener('click', () => {
                                // Toggle selection
                                if (card.classList.contains('selected')) {
                                    card.classList.remove('selected');
                                    this.selectedStars = this.selectedStars.filter(name => name !== player.name);
                                } else {
                                    card.classList.add('selected');
                                    this.selectedStars.push(player.name);
                                }
                            });
                        }
                        
                        this.elements.starPlayersGrid.appendChild(card);
                    });
                    
                    // Show modal
                    this.elements.starPlayersModal.classList.remove('hidden');
                },
                
                // Confirm selected star players
                confirmStarPlayers() {
                    this.updatePlayerStatusCounts();
                    this.elements.starPlayersModal.classList.add('hidden');
                    this.showToast(`${this.selectedStars.length} cabeças de chave selecionados!`, 'success');
                },
                
                // Open Weak Players Modal
                openWeakPlayersModal() {
                    // Get available players
                    const availablePlayers = this.players.filter(p => p.available);
                    
                    if (availablePlayers.length === 0) {
                        this.showToast('Nenhum jogador disponível para seleção!', 'error');
                        return;
                    }
                    
                    // Clear and populate grid
                    this.elements.weakPlayersGrid.innerHTML = '';
                    
                    // Sort players by level (ascending)
                    const sortedPlayers = [...availablePlayers].sort((a, b) => a.level - b.level);
                    
                    sortedPlayers.forEach(player => {
                        const isSelected = this.selectedWeaks.includes(player.name);
                        const isStar = this.selectedStars.includes(player.name);
                        const card = document.createElement('div');
                        
                        // If the player is already a star, it can't be a weak
                        const disabledClass = isStar ? 'opacity-50 cursor-not-allowed' : '';
                        
                        card.className = `player-card ${isSelected ? 'selected' : ''} ${disabledClass}`;
                        card.dataset.name = player.name;
                        
                        // Add position color indicator
                        let positionBg = '';
                        if (player.position === 'ZAG') positionBg = 'bg-red-100 text-red-800';
                        else if (player.position === 'MEI') positionBg = 'bg-green-100 text-green-800';
                        else if (player.position === 'ATA') positionBg = 'bg-blue-100 text-blue-800';
                        
                        card.innerHTML = `
                            <div class="w-8 h-8 rounded-full bg-primary mb-1 flex items-center justify-center text-white font-bold">
                                ${player.level}
                            </div>
                            <div class="text-sm font-medium truncate max-w-full">${player.name}</div>
                            <div class="text-xs ${positionBg} px-2 py-0.5 rounded mt-1">${player.position}</div>
                        `;
                        
                        // Only add click event if not disabled
                        if (!isStar) {
                            card.addEventListener('click', () => {
                                // Toggle selection
                                if (card.classList.contains('selected')) {
                                    card.classList.remove('selected');
                                    this.selectedWeaks = this.selectedWeaks.filter(name => name !== player.name);
                                } else {
                                    card.classList.add('selected');
                                    this.selectedWeaks.push(player.name);
                                }
                            });
                        }
                        
                        this.elements.weakPlayersGrid.appendChild(card);
                    });
                    
                    // Show modal
                    this.elements.weakPlayersModal.classList.remove('hidden');
                },
                
                // Confirm selected weak players
                confirmWeakPlayers() {
                    this.updatePlayerStatusCounts();
                    this.elements.weakPlayersModal.classList.add('hidden');
                    this.showToast(`${this.selectedWeaks.length} perebas selecionados!`, 'success');
                },
                
                // Update player status counts
                updatePlayerStatusCounts() {
                    this.elements.starsCount.textContent = this.selectedStars.length;
                    this.elements.weaksCount.textContent = this.selectedWeaks.length;
                },
                
                // Check if player is star in current draw
                isPlayerStar(playerName) {
                    return this.selectedStars.includes(playerName);
                },
                
                // Check if player is weak in current draw
                isPlayerWeak(playerName) {
                    return this.selectedWeaks.includes(playerName);
                },
                
                // Export players to a JSON file
                exportPlayers() {
                    if (this.players.length === 0) {
                        this.showToast('Nenhum jogador para exportar!', 'error');
                        return;
                    }
                    
                    // Create a simplified version with only the needed fields
                    const playersToExport = this.players.map(player => ({
                        name: player.name,
                        position: player.position,
                        level: player.level
                    }));
                    
                    const dataStr = JSON.stringify(playersToExport, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    const url = URL.createObjectURL(dataBlob);
                    
                    // Create a temporary link and click it to trigger download
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'pelada_jogadores.json';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    this.showToast('Jogadores exportados com sucesso!', 'success');
                },
                
                // Import players from a JSON file
                importPlayers(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            const importedPlayers = JSON.parse(e.target.result);
                            
                            if (!Array.isArray(importedPlayers)) {
                                throw new Error('Formato inválido. Esperava uma lista de jogadores.');
                            }
                            
                            // Validate required fields
                            const validPlayers = importedPlayers.filter(player => 
                                player.name && player.position && typeof player.level === 'number'
                            );
                            
                            if (validPlayers.length === 0) {
                                this.showToast('Nenhum jogador válido encontrado no arquivo!', 'error');
                                return;
                            }
                            
                            // Confirm before importing
                            if (confirm(`Deseja importar ${validPlayers.length} jogadores? Jogadores com o mesmo nome serão atualizados.`)) {
                                let added = 0;
                                let updated = 0;
                                
                                validPlayers.forEach(importedPlayer => {
                                    // Check if player already exists by name
                                    const existingPlayer = this.players.find(p => 
                                        p.name.toLowerCase() === importedPlayer.name.toLowerCase()
                                    );
                                    
                                    if (existingPlayer) {
                                        // Update existing player
                                        existingPlayer.position = importedPlayer.position;
                                        existingPlayer.level = importedPlayer.level;
                                        updated++;
                                    } else {
                                        // Add new player
                                        const newPlayer = {
                                            id: this.currentId++,
                                            name: importedPlayer.name,
                                            position: importedPlayer.position,
                                            level: importedPlayer.level,
                                            available: true
                                        };
                                        
                                        this.players.push(newPlayer);
                                        added++;
                                    }
                                });
                                
                                // Save changes
                                this.savePlayers();
                                
                                // Update UI
                                this.updateStats();
                                this.updatePlayerList();
                                this.updateRestrictionPlayersDropdown();
                                
                                this.showToast(`Importação concluída! ${added} adicionados, ${updated} atualizados.`, 'success');
                            }
                        } catch (error) {
                            console.error('Erro ao importar jogadores:', error);
                            this.showToast('Erro ao importar jogadores. Verifique o formato do arquivo.', 'error');
                        }
                    };
                    
                    reader.readAsText(file);
                    
                    // Reset the file input so the same file can be selected again
                    event.target.value = '';
                },
                
                // Add a new player or update existing player
                savePlayer() {
                    const playerId = this.elements.playerId.value;
                    const name = this.elements.playerName.value.trim();
                    const position = this.elements.playerPosition.value;
                    const level = parseFloat(this.elements.playerLevel.value);
                    const available = this.elements.playerAvailable.checked;
                    
                    // Validate form
                    if (!name || !position) {
                        this.showToast('Nome e posição são obrigatórios!', 'error');
                        return;
                    }
                    
                    // Check for duplicate name
                    if (this.players.some(p => p.name.toLowerCase() === name.toLowerCase() && 
                        (!playerId || p.id !== parseInt(playerId)))) {
                        this.showToast('Já existe um jogador com esse nome!', 'error');
                        return;
                    }
                    
                    if (playerId) {
                        // Update existing player
                        const index = this.players.findIndex(p => p.id === parseInt(playerId));
                        if (index !== -1) {
                            // Get old name to update restrictions if needed
                            const oldName = this.players[index].name;
                            
                            this.players[index] = {
                                id: parseInt(playerId),
                                name,
                                position,
                                level,
                                available
                            };
                            
                            // Update player in restrictions if name changed
                            if (oldName !== name) {
                                this.updatePlayerInRestrictions(oldName, name);
                                
                                // Update in selectedStars and selectedWeaks if necessary
                                if (this.selectedStars.includes(oldName)) {
                                    this.selectedStars = this.selectedStars.filter(n => n !== oldName);
                                    this.selectedStars.push(name);
                                }
                                if (this.selectedWeaks.includes(oldName)) {
                                    this.selectedWeaks = this.selectedWeaks.filter(n => n !== oldName);
                                    this.selectedWeaks.push(name);
                                }
                            }
                            
                            this.showToast('Jogador atualizado com sucesso!', 'success');
                        }
                    } else {
                        // Add new player
                        const newPlayer = {
                            id: this.currentId++,
                            name,
                            position,
                            level,
                            available
                        };
                        this.players.push(newPlayer);
                        this.showToast('Jogador adicionado com sucesso!', 'success');
                    }
                    
                    // Save players to localStorage
                    this.savePlayers();
                    
                    // Reset form
                    this.resetForm();
                    
                    // Update stats and UI
                    this.updateStats();
                    this.updatePlayerList();
                    this.updateRestrictionPlayersDropdown();
                    this.updatePlayerStatusCounts();
                },
                
                // Add a restriction between two players
                addRestriction() {
                    const player1 = this.elements.restrictionPlayer1.value;
                    const player2 = this.elements.restrictionPlayer2.value;
                    
                    // Validate selection
                    if (!player1 || !player2) {
                        this.showToast('Selecione dois jogadores!', 'error');
                        return;
                    }
                    
                    if (player1 === player2) {
                        this.showToast('Selecione jogadores diferentes!', 'error');
                        return;
                    }
                    
                    // Check if restriction already exists
                    const exists = this.playerRestrictions.some(r => 
                        (r.player1 === player1 && r.player2 === player2) || 
                        (r.player1 === player2 && r.player2 === player1)
                    );
                    
                    if (exists) {
                        this.showToast('Esta restrição já existe!', 'error');
                        return;
                    }
                    
                    // Add restriction
                    this.playerRestrictions.push({
                        id: Date.now(), // Simple unique ID
                        player1,
                        player2
                    });
                    
                    // Save restrictions
                    this.saveRestrictions();
                    
                    // Update UI
                    this.updateRestrictionsList();
                    
                    // Reset form
                    this.elements.restrictionPlayer1.value = '';
                    this.elements.restrictionPlayer2.value = '';
                    
                    this.showToast('Restrição adicionada com sucesso!', 'success');
                },
                
                // Delete a restriction
                deleteRestriction(id) {
                    this.playerRestrictions = this.playerRestrictions.filter(r => r.id !== id);
                    this.saveRestrictions();
                    this.updateRestrictionsList();
                    this.showToast('Restrição removida com sucesso!', 'success');
                },
                
                // Update player name in restrictions
                updatePlayerInRestrictions(oldName, newName) {
                    let updated = false;
                    
                    this.playerRestrictions.forEach(r => {
                        if (r.player1 === oldName) {
                            r.player1 = newName;
                            updated = true;
                        }
                        if (r.player2 === oldName) {
                            r.player2 = newName;
                            updated = true;
                        }
                    });
                    
                    if (updated) {
                        this.saveRestrictions();
                        this.updateRestrictionsList();
                    }
                },
                
                // Update restrictions list UI
                updateRestrictionsList() {
                    // Show/hide no restrictions message
                    if (this.playerRestrictions.length === 0) {
                        this.elements.noRestrictions.classList.remove('hidden');
                        this.elements.restrictionsList.classList.add('hidden');
                        return;
                    } else {
                        this.elements.noRestrictions.classList.add('hidden');
                        this.elements.restrictionsList.classList.remove('hidden');
                    }
                    
                    // Clear list
                    this.elements.restrictionsList.innerHTML = '';
                    
                    // Add each restriction
                    this.playerRestrictions.forEach(r => {
                        const li = document.createElement('li');
                        li.className = 'bg-gray-50 p-3 rounded-lg border border-gray-200 flex justify-between items-center';
                        li.innerHTML = `
                            <div>
                                <span class="font-medium">${r.player1}</span>
                                <span class="mx-2 text-red-500"><i class="fas fa-times"></i></span>
                                <span class="font-medium">${r.player2}</span>
                            </div>
                            <button class="delete-restriction text-red-500 hover:text-red-700" data-id="${r.id}">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                        `;
                        
                        this.elements.restrictionsList.appendChild(li);
                    });
                    
                    // Add event listeners to delete buttons
                    document.querySelectorAll('.delete-restriction').forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.deleteRestriction(parseInt(btn.getAttribute('data-id')));
                        });
                    });
                },
                
                // Update restriction players dropdown
                updateRestrictionPlayersDropdown() {
                    // Clear current options except the first one
                    while (this.elements.restrictionPlayer1.options.length > 1) {
                        this.elements.restrictionPlayer1.remove(1);
                    }
                    
                    while (this.elements.restrictionPlayer2.options.length > 1) {
                        this.elements.restrictionPlayer2.remove(1);
                    }
                    
                    // Sort players by name
                    const sortedPlayers = [...this.players].sort((a, b) => a.name.localeCompare(b.name));
                    
                    // Add players to the dropdowns
                    sortedPlayers.forEach(player => {
                        const option1 = document.createElement('option');
                        option1.value = player.name;
                        option1.textContent = player.name;
                        this.elements.restrictionPlayer1.appendChild(option1);
                        
                        const option2 = document.createElement('option');
                        option2.value = player.name;
                        option2.textContent = player.name;
                        this.elements.restrictionPlayer2.appendChild(option2);
                    });
                },
                
                // Edit a player
                editPlayer(id) {
                    const player = this.players.find(p => p.id === id);
                    if (player) {
                        this.editingPlayer = player;
                        
                        // Fill form with player data
                        this.elements.playerId.value = player.id;
                        this.elements.playerName.value = player.name;
                        this.elements.playerPosition.value = player.position;
                        this.elements.playerLevel.value = player.level;
                        this.elements.levelValue.textContent = player.level;
                        this.elements.playerAvailable.checked = player.available;
                        
                        // Update form title and show cancel button
                        this.elements.formTitle.textContent = 'Editar Jogador';
                        this.elements.cancelButton.classList.remove('hidden');
                    }
                },
                
                // Delete a player
                deletePlayer(id) {
                    if (confirm('Tem certeza que deseja excluir este jogador?')) {
                        const playerToDelete = this.players.find(p => p.id === id);
                        if (playerToDelete) {
                            // Remove player from restrictions
                            this.playerRestrictions = this.playerRestrictions.filter(r =>
                                r.player1 !== playerToDelete.name && r.player2 !== playerToDelete.name
                            );
                            this.saveRestrictions();
                            this.updateRestrictionsList();
                            
                            // Remove from selected stars/weaks if present
                            this.selectedStars = this.selectedStars.filter(name => name !== playerToDelete.name);
                            this.selectedWeaks = this.selectedWeaks.filter(name => name !== playerToDelete.name);
                        }
                        
                        this.players = this.players.filter(p => p.id !== id);
                        
                        // Save players to localStorage
                        this.savePlayers();
                        
                        // Update stats and UI
                        this.updateStats();
                        this.updatePlayerList();
                        this.updateRestrictionPlayersDropdown();
                        this.updatePlayerStatusCounts();
                        
                        this.showToast('Jogador excluído com sucesso!', 'success');
                    }
                },
                
                // Cancel player edit
                cancelEdit() {
                    this.resetForm();
                    this.showToast('Edição cancelada', 'info');
                },
                
                // Reset the player form
                resetForm() {
                    this.editingPlayer = null;
                    this.elements.playerForm.reset();
                    this.elements.playerId.value = '';
                    this.elements.levelValue.textContent = '3.0';
                    this.elements.playerLevel.value = 3.0;
                    this.elements.formTitle.textContent = 'Adicionar Jogador';
                    this.elements.cancelButton.classList.add('hidden');
                },
                
                // Update player list in the UI
                updatePlayerList() {
                    const searchTerm = this.elements.playerSearch.value.toLowerCase();
                    const filteredPlayers = searchTerm 
                        ? this.players.filter(p => p.name.toLowerCase().includes(searchTerm))
                        : this.players;
                    
                    this.elements.playerTableBody.innerHTML = '';
                    
                    if (filteredPlayers.length === 0) {
                        const emptyRow = document.createElement('tr');
                        emptyRow.innerHTML = `
                            <td colspan="5" class="py-4 px-4 text-center text-gray-500">
                                ${searchTerm ? 'Nenhum jogador encontrado.' : 'Nenhum jogador cadastrado.'}
                            </td>
                        `;
                        this.elements.playerTableBody.appendChild(emptyRow);
                        return;
                    }
                    
                    // Sort players by name
                    const sortedPlayers = [...filteredPlayers].sort((a, b) => a.name.localeCompare(b.name));
                    
                    sortedPlayers.forEach(player => {
                        const row = document.createElement('tr');
                        row.className = 'border-b hover:bg-gray-50 transition-colors';
                        
                        let positionClass = '';
                        if (player.position === 'ZAG') positionClass = 'bg-red-100 text-red-800';
                        else if (player.position === 'MEI') positionClass = 'bg-green-100 text-green-800';
                        else if (player.position === 'ATA') positionClass = 'bg-blue-100 text-blue-800';
                        
                        row.innerHTML = `
                            <td class="py-3 px-4">${player.name}</td>
                            <td class="py-3 px-4">
                                <span class="px-2 py-1 rounded-full text-xs ${positionClass}">${player.position}</span>
                            </td>
                            <td class="py-3 px-4">
                                <div class="inline-block w-8 h-8 rounded-full bg-primary flex items-center justify-center text-white font-bold">${player.level}</div>
                            </td>
                            <td class="py-3 px-4">
                                <label class="toggle-switch">
                                    <input type="checkbox" class="player-available-toggle" data-id="${player.id}" ${player.available ? 'checked' : ''}>
                                    <span class="toggle-slider"></span>
                                </label>
                            </td>
                            <td class="py-3 px-4">
                                <div class="flex space-x-2">
                                    <button class="edit-player-btn text-blue-600 hover:text-blue-800" data-id="${player.id}">
                                        <i class="fas fa-edit"></i>
                                    </button>
                                    <button class="delete-player-btn text-red-600 hover:text-red-800" data-id="${player.id}">
                                        <i class="fas fa-trash-alt"></i>
                                    </button>
                                </div>
                            </td>
                        `;
                        
                        this.elements.playerTableBody.appendChild(row);
                    });
                    
                    // Add event listeners to the new buttons
                    document.querySelectorAll('.edit-player-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.editPlayer(parseInt(btn.getAttribute('data-id')));
                        });
                    });
                    
                    document.querySelectorAll('.delete-player-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.deletePlayer(parseInt(btn.getAttribute('data-id')));
                        });
                    });
                    
                    document.querySelectorAll('.player-available-toggle').forEach(toggle => {
                        toggle.addEventListener('change', (e) => {
                            const id = parseInt(toggle.getAttribute('data-id'));
                            const player = this.players.find(p => p.id === id);
                            if (player) {
                                player.available = toggle.checked;
                                this.savePlayers();
                                this.updateStats();
                                
                                // If player is no longer available, remove from selected stars/weaks
                                if (!player.available) {
                                    this.selectedStars = this.selectedStars.filter(name => name !== player.name);
                                    this.selectedWeaks = this.selectedWeaks.filter(name => name !== player.name);
                                    this.updatePlayerStatusCounts();
                                }
                            }
                        });
                    });
                },
                
                // Filter players by name
                filterPlayers() {
                    this.updatePlayerList();
                },
                
                // Update player statistics
                updateStats() {
                    const totalPlayers = this.players.length;
                    const availablePlayers = this.players.filter(p => p.available).length;
                    const zagCount = this.players.filter(p => p.position === 'ZAG').length;
                    const meiCount = this.players.filter(p => p.position === 'MEI').length;
                    const ataCount = this.players.filter(p => p.position === 'ATA').length;
                    
                    // Calculate average level of available players
                    let avgLevel = 0;
                    if (availablePlayers > 0) {
                        const totalLevel = this.players
                            .filter(p => p.available)
                            .reduce((sum, p) => sum + p.level, 0);
                        avgLevel = totalLevel / availablePlayers;
                    }
                    
                    // Update stats in the UI
                    this.elements.totalPlayers.textContent = totalPlayers;
                    this.elements.availablePlayers.textContent = availablePlayers;
                    this.elements.zagCount.textContent = zagCount;
                    this.elements.meiCount.textContent = meiCount;
                    this.elements.ataCount.textContent = ataCount;
                    this.elements.avgLevel.textContent = avgLevel.toFixed(1);
                    
                    // Update toggle all button text
                    if (totalPlayers > 0) {
                        const allAvailable = totalPlayers === availablePlayers;
                        this.elements.toggleAllBtn.innerHTML = allAvailable 
                            ? '<i class="fas fa-toggle-off mr-2"></i>Ninguém Disponível'
                            : '<i class="fas fa-toggle-on mr-2"></i>Todos Disponíveis';
                    }
                },
                
                // Toggle all players availability
                toggleAllPlayers() {
                    if (this.players.length === 0) {
                        this.showToast('Nenhum jogador cadastrado!', 'error');
                        return;
                    }
                    
                    const allAvailable = this.players.every(p => p.available);
                    this.players.forEach(p => p.available = !allAvailable);
                    
                    // Save players to localStorage
                    this.savePlayers();
                    
                    // If setting to not available, clear selections
                    if (allAvailable) {
                        this.selectedStars = [];
                        this.selectedWeaks = [];
                        this.updatePlayerStatusCounts();
                    }
                    
                    // Update stats and UI
                    this.updateStats();
                    this.updatePlayerList();
                    
                    this.showToast(`Todos os jogadores estão ${allAvailable ? 'indisponíveis' : 'disponíveis'} agora!`, 'success');
                },
                
                // Clear all players
                clearAllPlayers() {
                    this.players = [];
                    this.currentId = 1;
                    
                    // Clear restrictions too
                    this.playerRestrictions = [];
                    this.saveRestrictions();
                    this.updateRestrictionsList();
                    
                    // Clear selections
                    this.selectedStars = [];
                    this.selectedWeaks = [];
                    this.updatePlayerStatusCounts();
                    
                    // Save players to localStorage
                    this.savePlayers();
                    
                    // Update stats and UI
                    this.updateStats();
                    this.updatePlayerList();
                    
                    this.showToast('Todos os jogadores foram removidos!', 'success');
                },
                
                // Update team names inputs
                updateTeamNamesInputs() {
                    const numberOfTeams = parseInt(this.elements.numberOfTeams.value);
                    
                    // Clear container
                    this.elements.teamNamesContainer.innerHTML = '<label class="block font-medium">Nomes dos Times</label>';
                    
                    // Default team names
                    const defaultNames = ['Time A', 'Time B', 'Time C', 'Time D'];
                    
                    // Add inputs for each team
                    for (let i = 0; i < numberOfTeams; i++) {
                        const div = document.createElement('div');
                        div.className = 'team-name-input';
                        div.innerHTML = `
                            <label class="text-sm text-gray-600">Time ${i + 1}</label>
                            <input 
                                type="text" 
                                class="team-name w-full px-4 py-2 rounded-lg border border-gray-300 bg-white text-base focus:outline-none focus:ring-2 focus:ring-primary"
                                value="${defaultNames[i]}"
                                placeholder="Nome do time"
                            >
                        `;
                        this.elements.teamNamesContainer.appendChild(div);
                    }
                },
                
                // Check if two players have a restriction
                playersHaveRestriction(player1Name, player2Name) {
                    return this.playerRestrictions.some(r => 
                        (r.player1 === player1Name && r.player2 === player2Name) || 
                        (r.player1 === player2Name && r.player2 === player1Name)
                    );
                },
                
                // Draw teams
                drawTeams() {
                    // Get available players
                    const availablePlayers = this.players.filter(p => p.available);
                    
                    // Check if there are enough players
                    if (availablePlayers.length === 0) {
                        this.showToast('Nenhum jogador disponível para sorteio!', 'error');
                        return;
                    }
                    
                    // Get configuration
                    const playersPerTeam = parseInt(this.elements.playersPerTeam.value);
                    const numberOfTeams = parseInt(this.elements.numberOfTeams.value);
                    
                    // Check if there are enough players for the number of teams
                    if (availablePlayers.length < numberOfTeams) {
                        this.showToast(`Não há jogadores suficientes para ${numberOfTeams} times!`, 'error');
                        return;
                    }
                    
                    // Get team names
                    const teamNameInputs = document.querySelectorAll('.team-name');
                    const teamNames = Array.from(teamNameInputs).map(input => input.value.trim() || 'Time');
                    
                    // Show draw progress
                    this.elements.drawProgress.classList.remove('hidden');
                    this.elements.balanceIndicator.classList.add('hidden');
                    this.elements.drawTeamsBtn.disabled = true;
                    this.sortingInProgress = true;
                    
                    // Reset progress bar
                    this.elements.progressBar.style.width = '0%';
                    this.elements.progressText.textContent = 'Procurando equilíbrio ideal...';
                    
                    // Perform draw algorithm asynchronously
                    setTimeout(() => {
                        const result = this.performTeamDraw(availablePlayers, playersPerTeam, numberOfTeams, teamNames);
                        this.drawnTeams = result.teams;
                        
                        // Hide draw progress
                        this.elements.drawProgress.classList.add('hidden');
                        this.elements.balanceIndicator.classList.remove('hidden');
                        
                        // Show balance indicator
                        const balancePercentage = Math.min(100, Math.max(0, result.balanceScore * 100));
                        this.elements.balanceBar.style.width = `${balancePercentage}%`;
                        this.elements.balanceValue.textContent = `${balancePercentage.toFixed(0)}%`;
                        
                        // Set balance bar color
                        if (balancePercentage >= 80) {
                            this.elements.balanceBar.className = 'bg-green-500 h-4 rounded-full';
                        } else if (balancePercentage >= 60) {
                            this.elements.balanceBar.className = 'bg-yellow-500 h-4 rounded-full';
                        } else {
                            this.elements.balanceBar.className = 'bg-red-500 h-4 rounded-full';
                        }
                        
                        // Show accept/try again buttons
                        this.elements.acceptBalanceBtn.classList.remove('hidden');
                        this.elements.tryAgainBtn.classList.remove('hidden');
                        
                        // Display teams with hidden names
                        this.displayTeams(false);
                        
                        // Allow trying again
                        this.elements.drawTeamsBtn.disabled = false;
                        this.sortingInProgress = false;
                    }, 500);
                },
                
                // Perform team draw algorithm
                performTeamDraw(availablePlayers, playersPerTeam, numberOfTeams, teamNames) {
                    // Get stars and weak players based on current selections
                    const starPlayers = availablePlayers.filter(p => this.selectedStars.includes(p.name));
                    const weakPlayers = availablePlayers.filter(p => this.selectedWeaks.includes(p.name));
                    const regularPlayers = availablePlayers.filter(p => 
                        !this.selectedStars.includes(p.name) && !this.selectedWeaks.includes(p.name)
                    );
                    
                    // Count available players by position
                    const positions = ['ZAG', 'MEI', 'ATA'];
                    const availableByPosition = {};
                    positions.forEach(pos => {
                        availableByPosition[pos] = availablePlayers.filter(p => p.position === pos).length;
                    });
                    
                    // Initialize best result
                    let bestTry = {
                        teams: [],
                        balanceScore: 0,
                        levelDeviation: Number.MAX_VALUE
                    };
                    
                    const maxTries = 100;
                    
                    // Try multiple times to find the best balance
                    for (let tryIndex = 0; tryIndex < maxTries; tryIndex++) {
                        // Update progress bar
                        this.elements.progressBar.style.width = `${(tryIndex / maxTries) * 100}%`;
                        
                        // Create empty teams
                        const teams = teamNames.map((name, index) => ({
                            name,
                            players: [],
                            totalLevel: 0,
                            index,
                            positions: {ZAG: 0, MEI: 0, ATA: 0},
                            starCount: 0,
                            weakCount: 0
                        }));
                        
                        // Distribute stars first, one per team if possible
                        let availableStars = [...starPlayers];
                        if (availableStars.length > 0) {
                            // Shuffle stars
                            availableStars = this.shuffleArray(availableStars);
                            
                            // Distribute one star per team if possible
                            for (let i = 0; i < Math.min(teams.length, availableStars.length); i++) {
                                teams[i].players.push(availableStars[i]);
                                teams[i].totalLevel += availableStars[i].level;
                                teams[i].positions[availableStars[i].position]++;
                                teams[i].starCount++;
                            }
                            
                            // Put remaining stars to the teams with lowest levels and fewer stars
                            if (availableStars.length > teams.length) {
                                const remainingStars = availableStars.slice(teams.length);
                                
                                // Sort teams by star count first, then by level
                                teams.sort((a, b) => {
                                    if (a.starCount !== b.starCount) {
                                        return a.starCount - b.starCount;
                                    } else {
                                        return a.totalLevel - b.totalLevel;
                                    }
                                });
                                
                                remainingStars.forEach(starPlayer => {
                                    // Find team with fewest stars and check restrictions
                                    let targetTeam = null;
                                    for (let i = 0; i < teams.length; i++) {
                                        const hasRestriction = teams[i].players.some(p => 
                                            this.playersHaveRestriction(p.name, starPlayer.name)
                                        );
                                        
                                        if (!hasRestriction) {
                                            targetTeam = teams[i];
                                            break;
                                        }
                                    }
                                    
                                    // If no team found without restrictions, use first team
                                    if (!targetTeam) {
                                        targetTeam = teams[0];
                                    }
                                    
                                    // Add star to target team
                                    targetTeam.players.push(starPlayer);
                                    targetTeam.totalLevel += starPlayer.level;
                                    targetTeam.positions[starPlayer.position]++;
                                    targetTeam.starCount++;
                                    
                                    // Re-sort teams
                                    teams.sort((a, b) => {
                                        if (a.starCount !== b.starCount) {
                                            return a.starCount - b.starCount;
                                        } else {
                                            return a.totalLevel - b.totalLevel;
                                        }
                                    });
                                });
                            }
                        }
                        
                        // Distribute weaks second, one per team if possible
                        let availableWeaks = [...weakPlayers];
                        if (availableWeaks.length > 0) {
                            // Shuffle weaks
                            availableWeaks = this.shuffleArray(availableWeaks);
                            
                            // Sort teams by level (descending)
                            teams.sort((a, b) => b.totalLevel - a.totalLevel);
                            
                            // Distribute one weak per team if possible
                            for (let i = 0; i < Math.min(teams.length, availableWeaks.length); i++) {
                                const weakPlayer = availableWeaks[i];
                                
                                // Check restrictions
                                const hasRestriction = teams[i].players.some(p => 
                                    this.playersHaveRestriction(p.name, weakPlayer.name)
                                );
                                
                                if (hasRestriction) {
                                    // Find another team without restrictions
                                    const teamsWithoutRestrictions = teams.filter(team => 
                                        !team.players.some(p => this.playersHaveRestriction(p.name, weakPlayer.name))
                                    );
                                    
                                    if (teamsWithoutRestrictions.length > 0) {
                                        // Get team with highest level among those without restrictions
                                        const alternateTeam = teamsWithoutRestrictions.reduce((prev, curr) => 
                                            prev.totalLevel > curr.totalLevel ? prev : curr
                                        );
                                        
                                        alternateTeam.players.push(weakPlayer);
                                        alternateTeam.totalLevel += weakPlayer.level;
                                        alternateTeam.positions[weakPlayer.position]++;
                                        alternateTeam.weakCount++;
                                    } else {
                                        // If all teams have restrictions, still add to highest level team
                                        teams[i].players.push(weakPlayer);
                                        teams[i].totalLevel += weakPlayer.level;
                                        teams[i].positions[weakPlayer.position]++;
                                        teams[i].weakCount++;
                                    }
                                } else {
                                    teams[i].players.push(weakPlayer);
                                    teams[i].totalLevel += weakPlayer.level;
                                    teams[i].positions[weakPlayer.position]++;
                                    teams[i].weakCount++;
                                }
                            }
                            
                            // Sort teams by level and weak count for remaining weaks
                            if (availableWeaks.length > teams.length) {
                                const remainingWeaks = availableWeaks.slice(teams.length);
                                
                                // Sort teams by weak count first, then by level (highest level first)
                                teams.sort((a, b) => {
                                    if (a.weakCount !== b.weakCount) {
                                        return a.weakCount - b.weakCount;
                                    } else {
                                        return b.totalLevel - a.totalLevel;
                                    }
                                });
                                
                                remainingWeaks.forEach(weakPlayer => {
                                    // Find team with fewest weaks and check restrictions
                                    let targetTeam = null;
                                    for (let i = 0; i < teams.length; i++) {
                                        const hasRestriction = teams[i].players.some(p => 
                                            this.playersHaveRestriction(p.name, weakPlayer.name)
                                        );
                                        
                                        if (!hasRestriction) {
                                            targetTeam = teams[i];
                                            break;
                                        }
                                    }
                                    
                                    // If no team found without restrictions, use first team
                                    if (!targetTeam) {
                                        targetTeam = teams[0];
                                    }
                                    
                                    // Add weak to target team
                                    targetTeam.players.push(weakPlayer);
                                    targetTeam.totalLevel += weakPlayer.level;
                                    targetTeam.positions[weakPlayer.position]++;
                                    targetTeam.weakCount++;
                                    
                                    // Re-sort teams
                                    teams.sort((a, b) => {
                                        if (a.weakCount !== b.weakCount) {
                                            return a.weakCount - b.weakCount;
                                        } else {
                                            return b.totalLevel - a.totalLevel;
                                        }
                                    });
                                });
                            }
                        }
                        
                        // Shuffle regular players
                        let remainingPlayers = [...regularPlayers];
                        
                        // PRIMEIRO PASSO: Distribuir jogadores por posição se houver suficientes
                        for (const position of positions) {
                            // Verificar se há jogadores suficientes desta posição
                            if (availableByPosition[position] >= numberOfTeams) {
                                // Primeiro, filtrar jogadores dessa posição dos restantes
                                const positionPlayers = remainingPlayers.filter(p => p.position === position);
                                
                                // Para cada time, verificar se já tem jogador nessa posição
                                for (const team of teams) {
                                    // Se já tem jogador nessa posição, continuar
                                    if (team.positions[position] > 0) continue;
                                    
                                    // Procurar jogador disponível que não tenha restrição
                                    const availablePlayer = positionPlayers.find(player => 
                                        !team.players.some(p => this.playersHaveRestriction(p.name, player.name))
                                    );
                                    
                                    if (availablePlayer) {
                                        // Adicionar jogador ao time
                                        team.players.push(availablePlayer);
                                        team.totalLevel += availablePlayer.level;
                                        team.positions[position]++;
                                        
                                        // Remover jogador das listas
                                        remainingPlayers = remainingPlayers.filter(p => p !== availablePlayer);
                                        const index = positionPlayers.indexOf(availablePlayer);
                                        if (index > -1) positionPlayers.splice(index, 1);
                                    } else if (positionPlayers.length > 0) {
                                        // Se não encontrou sem restrição, usar o primeiro disponível
                                        const player = positionPlayers[0];
                                        team.players.push(player);
                                        team.totalLevel += player.level;
                                        team.positions[position]++;
                                        
                                        // Remover jogador das listas
                                        remainingPlayers = remainingPlayers.filter(p => p !== player);
                                        positionPlayers.shift();
                                    }
                                }
                            }
                        }
                        
                        // Shuffle os jogadores restantes para aumentar aleatoriedade
                        remainingPlayers = this.shuffleArray(remainingPlayers);
                        
                        // SEGUNDO PASSO: Distribuir os restantes equilibrando por nível
                        // Calcular média-alvo (nível total esperado para cada time)
                        const totalPlayersLevel = availablePlayers.reduce((sum, p) => sum + p.level, 0);
                        const targetAvg = totalPlayersLevel / numberOfTeams;
                        
                        // Distribuir os jogadores restantes com base na proximidade da média
                        while (remainingPlayers.length > 0) {
                            // Ordenar times pelo desvio em relação à média alvo (do maior desvio para o menor)
                            teams.sort((a, b) => 
                                Math.abs(targetAvg - a.totalLevel) > Math.abs(targetAvg - b.totalLevel) ? -1 : 1
                            );
                            
                            // Pegar o time que está mais longe da média
                            const targetTeam = teams[0];
                            
                            // Verificar se o time já está completo
                            if (targetTeam.players.length >= playersPerTeam) {
                                // Se estiver, procurar o próximo time não completo
                                const nextTeam = teams.find(team => team.players.length < playersPerTeam);
                                if (nextTeam) {
                                    this.addOptimalPlayerToTeam(nextTeam, remainingPlayers, targetAvg);
                                } else {
                                    // Todos os times estão completos, encerrar o loop
                                    break;
                                }
                            } else {
                                this.addOptimalPlayerToTeam(targetTeam, remainingPlayers, targetAvg);
                            }
                        }
                        
                        // TERCEIRO PASSO: Verificar e corrigir as posições quando necessário
                        // Só precisamos fazer isso se houver jogadores suficientes de cada posição
                        for (const position of positions) {
                            if (availableByPosition[position] >= numberOfTeams) {
                                // Verifique quais times não têm jogadores desta posição
                                const teamsWithoutPosition = teams.filter(team => team.positions[position] === 0);
                                
                                // Se não houver times sem esta posição, pule para a próxima
                                if (teamsWithoutPosition.length === 0) continue;
                                
                                // Para cada time sem jogador desta posição
                                for (const teamWithoutPosition of teamsWithoutPosition) {
                                    // Encontre times com mais de um jogador desta posição
                                    const teamsWithExtra = teams.filter(team => 
                                        team !== teamWithoutPosition && team.positions[position] > 1
                                    );
                                    
                                    if (teamsWithExtra.length > 0) {
                                        // Escolha um time com jogador extra
                                        const donorTeam = teamsWithExtra[0];
                                        
                                        // Encontre o jogador desta posição para transferir
                                        const playerToTransfer = donorTeam.players.find(p => p.position === position);
                                        
                                        if (playerToTransfer) {
                                            // Verifique restrições
                                            const hasRestriction = teamWithoutPosition.players.some(p => 
                                                this.playersHaveRestriction(p.name, playerToTransfer.name)
                                            );
                                            
                                            if (!hasRestriction) {
                                                // Remova o jogador do time doador
                                                donorTeam.players = donorTeam.players.filter(p => p !== playerToTransfer);
                                                donorTeam.totalLevel -= playerToTransfer.level;
                                                donorTeam.positions[position]--;
                                                
                                                // Atualizar contagem de star/weak se aplicável
                                                if (this.selectedStars.includes(playerToTransfer.name)) {
                                                    donorTeam.starCount--;
                                                }
                                                if (this.selectedWeaks.includes(playerToTransfer.name)) {
                                                    donorTeam.weakCount--;
                                                }
                                                
                                                // Adicione ao time receptor
                                                teamWithoutPosition.players.push(playerToTransfer);
                                                teamWithoutPosition.totalLevel += playerToTransfer.level;
                                                teamWithoutPosition.positions[position]++;
                                                
                                                // Atualizar contagem de star/weak se aplicável
                                                if (this.selectedStars.includes(playerToTransfer.name)) {
                                                    teamWithoutPosition.starCount++;
                                                }
                                                if (this.selectedWeaks.includes(playerToTransfer.name)) {
                                                    teamWithoutPosition.weakCount++;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // PASSO FINAL: Garantir que todos os times tenham o mesmo número de jogadores
                        const targetPlayers = Math.min(playersPerTeam, Math.floor(availablePlayers.length / numberOfTeams));
                        
                        // Primeiro, garantir que nenhum time exceda o número alvo
                        teams.forEach(team => {
                            if (team.players.length > targetPlayers) {
                                const excessPlayers = team.players.splice(targetPlayers);
                                team.totalLevel = team.players.reduce((sum, p) => sum + p.level, 0);
                                
                                // Atualizar contagem de posições
                                team.positions = {ZAG: 0, MEI: 0, ATA: 0};
                                team.starCount = 0;
                                team.weakCount = 0;
                                team.players.forEach(p => {
                                    team.positions[p.position]++;
                                    if (this.selectedStars.includes(p.name)) team.starCount++;
                                    if (this.selectedWeaks.includes(p.name)) team.weakCount++;
                                });
                                
                                // Devolver jogadores excedentes para redistribuição
                                excessPlayers.forEach(p => remainingPlayers.push(p));
                            }
                        });
                        
                        // Depois, preencher times abaixo do alvo
                        if (remainingPlayers.length > 0) {
                            // Ordenar times por número de jogadores (crescente)
                            teams.sort((a, b) => a.players.length - b.players.length);
                            
                            while (remainingPlayers.length > 0) {
                                // Encontrar time com menos jogadores
                                const teamToFill = teams.find(team => team.players.length < targetPlayers);
                                if (!teamToFill) break;
                                
                                // Adicionar jogador ótimo para este time
                                this.addOptimalPlayerToTeam(teamToFill, remainingPlayers, targetAvg);
                                
                                // Reordenar times
                                teams.sort((a, b) => a.players.length - b.players.length);
                            }
                        }
                        
                        // FASE DE OTIMIZAÇÃO: Tentar trocas entre times para melhorar o equilíbrio
                        let improved = true;
                        let optimizationIterations = 0;
                        const maxOptimizationIterations = 20;
                        
                        while (improved && optimizationIterations < maxOptimizationIterations) {
                            improved = false;
                            optimizationIterations++;
                            
                            // Calcular média atual de cada time
                            const teamAvgs = teams.map(team => team.totalLevel / team.players.length);
                            const overallAvg = teamAvgs.reduce((sum, avg) => sum + avg, 0) / teams.length;
                            
                            // Ordenar times por desvio em relação à média geral (do maior para o menor)
                            const sortedTeams = [...teams].sort((a, b) => {
                                const aAvg = a.totalLevel / a.players.length;
                                const bAvg = b.totalLevel / b.players.length;
                                return Math.abs(overallAvg - aAvg) > Math.abs(overallAvg - bAvg) ? -1 : 1;
                            });
                            
                            // Tentar trocar jogadores entre times para melhorar o equilíbrio
                            for (let i = 0; i < sortedTeams.length && !improved; i++) {
                                const teamA = sortedTeams[i];
                                const avgA = teamA.totalLevel / teamA.players.length;
                                const diffA = avgA - overallAvg;
                                
                                for (let j = 0; j < sortedTeams.length && !improved; j++) {
                                    if (i === j) continue;
                                    
                                    const teamB = sortedTeams[j];
                                    const avgB = teamB.totalLevel / teamB.players.length;
                                    const diffB = avgB - overallAvg;
                                    
                                    // Se os times estão em lados opostos da média, podemos tentar trocar
                                    if ((diffA > 0 && diffB < 0) || (diffA < 0 && diffB > 0)) {
                                        // Tentar encontrar uma troca que melhore o equilíbrio
                                        improved = this.tryPlayerSwap(teamA, teamB, overallAvg, positions, availableByPosition);
                                    }
                                }
                            }
                        }
                        
                        // Calcular pontuação final de equilíbrio
                        const avgTeamLevel = teams.reduce((sum, team) => sum + team.totalLevel, 0) / teams.length;
                        const avgPerPlayer = teams.map(team => team.totalLevel / team.players.length);
                        const maxDeviation = Math.max(...teams.map(team => 
                            Math.abs(team.totalLevel / team.players.length - avgTeamLevel / teams[0].players.length)
                        ));
                        
                        // Um desvio menor é melhor
                        const balanceScore = 1 - (maxDeviation / (avgTeamLevel / teams[0].players.length));
                        
                        // Calcular pontuação de posição
                        let positionBalanceScore = 0;
                        for (const position of positions) {
                            if (availableByPosition[position] >= numberOfTeams) {
                                // Se há jogadores suficientes, verificar se todos os times têm pelo menos um
                                const allTeamsHavePosition = teams.every(team => team.positions[position] > 0);
                                if (allTeamsHavePosition) {
                                    positionBalanceScore += 1;
                                }
                            }
                        }
                        positionBalanceScore /= positions.length;
                        
                        // Calcular pontuação de restrições
                        let restrictionViolations = 0;
                        teams.forEach(team => {
                            // Verificar cada par de jogadores no time para restrições
                            for (let i = 0; i < team.players.length; i++) {
                                for (let j = i + 1; j < team.players.length; j++) {
                                    if (this.playersHaveRestriction(team.players[i].name, team.players[j].name)) {
                                        restrictionViolations++;
                                    }
                                }
                            }
                        });
                        
                        const restrictionScore = restrictionViolations === 0 ? 1 : 0;
                        
                        // Calcular desvio padrão das médias por jogador (quanto menor, melhor)
                        const avgOfAvgs = avgPerPlayer.reduce((sum, avg) => sum + avg, 0) / teams.length;
                        const varianceOfAvgs = avgPerPlayer.reduce((sum, avg) => sum + Math.pow(avg - avgOfAvgs, 2), 0) / teams.length;
                        const stdDevOfAvgs = Math.sqrt(varianceOfAvgs);
                        
                        // Calcular pontuação de distribuição de star/weak
                        const starWeakBalance = this.calculateStarWeakBalance(teams);
                        
                        // Pontuação combinada - dando maior peso ao equilíbrio de nível
                        const combinedScore = balanceScore * 0.5 + positionBalanceScore * 0.25 + 
                                             restrictionScore * 0.15 + starWeakBalance * 0.1;
                        
                        // Se for a melhor pontuação até agora ou tiver o menor desvio-padrão
                        if (combinedScore > bestTry.balanceScore || 
                            (combinedScore === bestTry.balanceScore && stdDevOfAvgs < bestTry.levelDeviation)) {
                            // Restaurar a ordem original dos times
                            teams.sort((a, b) => a.index - b.index);
                            
                            bestTry = {
                                teams,
                                balanceScore: combinedScore,
                                positionBalanceScore,
                                restrictionScore,
                                levelDeviation: stdDevOfAvgs,
                                starWeakBalance
                            };
                            
                            // Se alcançamos uma pontuação muito boa, podemos parar antes
                            if (combinedScore > 0.95 && stdDevOfAvgs < 0.1) {
                                break;
                            }
                        }
                    }
                    
                    // Finalizar barra de progresso
                    this.elements.progressBar.style.width = '100%';
                    this.elements.progressText.textContent = 'Sorteio concluído!';
                    
                    return bestTry;
                },
                
                // Calcular equilíbrio de distribuição de cabeças/perebas
                calculateStarWeakBalance(teams) {
                    if (teams.length <= 1) return 1; // Perfeito para um time
                    
                    // Verificar distribuição de cabeças de chave
                    const starCounts = teams.map(team => team.starCount);
                    const minStars = Math.min(...starCounts);
                    const maxStars = Math.max(...starCounts);
                    const starDiff = maxStars - minStars;
                    
                    // Verificar distribuição de perebas
                    const weakCounts = teams.map(team => team.weakCount);
                    const minWeaks = Math.min(...weakCounts);
                    const maxWeaks = Math.max(...weakCounts);
                    const weakDiff = maxWeaks - minWeaks;
                    
                    // Perfeitamente equilibrado = diferença de 0 ou 1 (inevitável se números ímpares)
                    const starBalance = starDiff <= 1 ? 1 : 1 - (starDiff - 1) / (this.selectedStars.length || 1);
                    const weakBalance = weakDiff <= 1 ? 1 : 1 - (weakDiff - 1) / (this.selectedWeaks.length || 1);
                    
                    // Média dos dois equilíbrios
                    return (starBalance + weakBalance) / 2;
                },
                
                // Tenta trocar jogadores entre times para melhorar o equilíbrio
                tryPlayerSwap(teamA, teamB, overallAvg, positions, availableByPosition) {
                    const avgA = teamA.totalLevel / teamA.players.length;
                    const avgB = teamB.totalLevel / teamB.players.length;
                    
                    // Determinar direção da troca
                    const teamAIsHigher = avgA > avgB;
                    
                    // Se teamA tem média mais alta, procuramos jogadores de teamA para trocar com teamB
                    const sourceTeam = teamAIsHigher ? teamA : teamB;
                    const targetTeam = teamAIsHigher ? teamB : teamA;
                    
                    // Vamos primeiro tentar trocas que melhorem o equilíbrio de posições
                    for (const position of positions) {
                        // Verificar se há um desequilíbrio de posições
                        if (sourceTeam.positions[position] > 1 && targetTeam.positions[position] === 0) {
                            // Procurar jogador da posição no time fonte
                            const playerToMove = sourceTeam.players.find(p => p.position === position);
                            
                            if (playerToMove) {
                                // Verificar restrições
                                const hasRestriction = targetTeam.players.some(p => 
                                    this.playersHaveRestriction(p.name, playerToMove.name)
                                );
                                
                                if (!hasRestriction) {
                                    // Procurar um jogador para trocar que melhore o equilíbrio de nível
                                    for (const targetPlayer of targetTeam.players) {
                                        // Calcular efeito da troca
                                        const newSourceTotal = sourceTeam.totalLevel - playerToMove.level + targetPlayer.level;
                                        const newTargetTotal = targetTeam.totalLevel - targetPlayer.level + playerToMove.level;
                                        
                                        const newAvgA = teamAIsHigher ? 
                                            newSourceTotal / sourceTeam.players.length : 
                                            newTargetTotal / targetTeam.players.length;
                                        
                                        const newAvgB = teamAIsHigher ? 
                                            newTargetTotal / targetTeam.players.length : 
                                            newSourceTotal / sourceTeam.players.length;
                                        
                                        const oldDiff = Math.abs(avgA - avgB);
                                        const newDiff = Math.abs(newAvgA - newAvgB);
                                        
                                        // Se a troca melhora o equilíbrio
                                        if (newDiff < oldDiff) {
                                            // Executar a troca
                                            // 1. Remover jogadores dos times atuais
                                            sourceTeam.players = sourceTeam.players.filter(p => p !== playerToMove);
                                            targetTeam.players = targetTeam.players.filter(p => p !== targetPlayer);
                                            
                                            // 2. Adicionar jogadores aos novos times
                                            sourceTeam.players.push(targetPlayer);
                                            targetTeam.players.push(playerToMove);
                                            
                                            // 3. Atualizar totais e posições
                                            sourceTeam.totalLevel = sourceTeam.players.reduce((sum, p) => sum + p.level, 0);
                                            targetTeam.totalLevel = targetTeam.players.reduce((sum, p) => sum + p.level, 0);
                                            
                                            sourceTeam.positions[playerToMove.position]--;
                                            sourceTeam.positions[targetPlayer.position]++;
                                            
                                            targetTeam.positions[targetPlayer.position]--;
                                            targetTeam.positions[playerToMove.position]++;
                                            
                                            // Atualizar contagem de star/weak se aplicável
                                            if (this.selectedStars.includes(playerToMove.name)) {
                                                sourceTeam.starCount--;
                                                targetTeam.starCount++;
                                            }
                                            if (this.selectedStars.includes(targetPlayer.name)) {
                                                sourceTeam.starCount++;
                                                targetTeam.starCount--;
                                            }
                                            if (this.selectedWeaks.includes(playerToMove.name)) {
                                                sourceTeam.weakCount--;
                                                targetTeam.weakCount++;
                                            }
                                            if (this.selectedWeaks.includes(targetPlayer.name)) {
                                                sourceTeam.weakCount++;
                                                targetTeam.weakCount--;
                                            }
                                            
                                            return true; // Troca realizada
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Se não melhoramos as posições, tentar apenas melhorar o nível
                    if (Math.abs(avgA - avgB) > 0.3) { // Só tenta se o desequilíbrio for significativo
                        const sourcePlayers = sourceTeam.players.sort((a, b) => 
                            teamAIsHigher ? b.level - a.level : a.level - b.level
                        );
                        
                        const targetPlayers = targetTeam.players.sort((a, b) => 
                            teamAIsHigher ? a.level - b.level : b.level - a.level
                        );
                        
                        // Testar trocas para melhorar o equilíbrio
                        for (const sourcePlayer of sourcePlayers) {
                            for (const targetPlayer of targetPlayers) {
                                // Verificar restrições
                                const sourceRestriction = targetTeam.players
                                    .filter(p => p !== targetPlayer)
                                    .some(p => this.playersHaveRestriction(p.name, sourcePlayer.name));
                                
                                const targetRestriction = sourceTeam.players
                                    .filter(p => p !== sourcePlayer)
                                    .some(p => this.playersHaveRestriction(p.name, targetPlayer.name));
                                
                                if (!sourceRestriction && !targetRestriction) {
                                    // Calcular efeito da troca
                                    const newSourceTotal = sourceTeam.totalLevel - sourcePlayer.level + targetPlayer.level;
                                    const newTargetTotal = targetTeam.totalLevel - targetPlayer.level + sourcePlayer.level;
                                    
                                    const newAvgA = newSourceTotal / sourceTeam.players.length;
                                    const newAvgB = newTargetTotal / targetTeam.players.length;
                                    
                                    const currentDiffFromOverall = 
                                        Math.abs(avgA - overallAvg) + Math.abs(avgB - overallAvg);
                                    
                                    const newDiffFromOverall = 
                                        Math.abs(newAvgA - overallAvg) + Math.abs(newAvgB - overallAvg);
                                    
                                    // Se a troca melhora a aproximação com a média geral
                                    if (newDiffFromOverall < currentDiffFromOverall) {
                                        // Executar a troca
                                        // 1. Remover jogadores dos times atuais
                                        sourceTeam.players = sourceTeam.players.filter(p => p !== sourcePlayer);
                                        targetTeam.players = targetTeam.players.filter(p => p !== targetPlayer);
                                        
                                        // 2. Adicionar jogadores aos novos times
                                        sourceTeam.players.push(targetPlayer);
                                        targetTeam.players.push(sourcePlayer);
                                        
                                        // 3. Atualizar totais e posições
                                        sourceTeam.totalLevel = sourceTeam.players.reduce((sum, p) => sum + p.level, 0);
                                        targetTeam.totalLevel = targetTeam.players.reduce((sum, p) => sum + p.level, 0);
                                        
                                        sourceTeam.positions[sourcePlayer.position]--;
                                        sourceTeam.positions[targetPlayer.position]++;
                                        
                                        targetTeam.positions[targetPlayer.position]--;
                                        targetTeam.positions[sourcePlayer.position]++;
                                        
                                        // Atualizar contagem de star/weak se aplicável
                                        if (this.selectedStars.includes(sourcePlayer.name)) {
                                            sourceTeam.starCount--;
                                            targetTeam.starCount++;
                                        }
                                        if (this.selectedStars.includes(targetPlayer.name)) {
                                            sourceTeam.starCount++;
                                            targetTeam.starCount--;
                                        }
                                        if (this.selectedWeaks.includes(sourcePlayer.name)) {
                                            sourceTeam.weakCount--;
                                            targetTeam.weakCount++;
                                        }
                                        if (this.selectedWeaks.includes(targetPlayer.name)) {
                                            sourceTeam.weakCount++;
                                            targetTeam.weakCount--;
                                        }
                                        
                                        return true; // Troca realizada
                                    }
                                }
                            }
                        }
                    }
                    
                    return false; // Nenhuma troca melhorando o equilíbrio foi encontrada
                },
                
                // Adiciona o jogador ideal para equilibrar o time em relação à média alvo
                addOptimalPlayerToTeam(team, remainingPlayers, targetAvg) {
                    // Filtrar jogadores sem restrições
                    const validPlayers = remainingPlayers.filter(p => 
                        !team.players.some(existingPlayer => 
                            this.playersHaveRestriction(existingPlayer.name, p.name)
                        )
                    );
                    
                    if (validPlayers.length === 0 && remainingPlayers.length > 0) {
                        // Se não houver jogadores sem restrições, use o primeiro disponível
                        const player = remainingPlayers.splice(0, 1)[0];
                        team.players.push(player);
                        team.totalLevel += player.level;
                        team.positions[player.position]++;
                        
                        // Atualizar contagem de star/weak se aplicável
                        if (this.selectedStars.includes(player.name)) team.starCount++;
                        if (this.selectedWeaks.includes(player.name)) team.weakCount++;
                        
                        return;
                    }
                    
                    // Calcular média atual do time
                    const currentAvg = team.players.length > 0 ? team.totalLevel / team.players.length : 0;
                    
                    // Decidir se precisamos adicionar um jogador acima ou abaixo da média
                    const needsHigherLevel = currentAvg < targetAvg;
                    
                    // Primeiro, priorizar posições ausentes se necessário
                    for (const position of ['ZAG', 'MEI', 'ATA']) {
                        if (team.positions[position] === 0) {
                            // Filtrar jogadores da posição ausente
                            const positionPlayers = validPlayers.filter(p => p.position === position);
                            
                            if (positionPlayers.length > 0) {
                                // Se tivermos jogadores da posição ausente, escolher baseado no nível
                                positionPlayers.sort((a, b) => needsHigherLevel ? b.level - a.level : a.level - b.level);
                                
                                // Encontrar o jogador que leva a média mais próxima do alvo
                                const bestPlayer = this.findBestPlayerForTarget(positionPlayers, team, targetAvg);
                                
                                // Remover e adicionar o jogador
                                const playerIndex = remainingPlayers.findIndex(p => p === bestPlayer);
                                const player = remainingPlayers.splice(playerIndex, 1)[0];
                                team.players.push(player);
                                team.totalLevel += player.level;
                                team.positions[player.position]++;
                                
                                // Atualizar contagem de star/weak se aplicável
                                if (this.selectedStars.includes(player.name)) team.starCount++;
                                if (this.selectedWeaks.includes(player.name)) team.weakCount++;
                                
                                return;
                            }
                        }
                    }
                    
                    // Se não precisamos priorizar posições ou não temos jogadores de posições ausentes
                    // Encontrar o jogador que leva a média mais próxima do alvo
                    const bestPlayer = this.findBestPlayerForTarget(validPlayers, team, targetAvg);
                    
                    // Remover e adicionar o jogador
                    const playerIndex = remainingPlayers.findIndex(p => p === bestPlayer);
                    const player = remainingPlayers.splice(playerIndex, 1)[0];
                    team.players.push(player);
                    team.totalLevel += player.level;
                    team.positions[player.position]++;
                    
                    // Atualizar contagem de star/weak se aplicável
                    if (this.selectedStars.includes(player.name)) team.starCount++;
                    if (this.selectedWeaks.includes(player.name)) team.weakCount++;
                },
                
                // Encontra o jogador que deixa a média do time mais próxima do alvo
                findBestPlayerForTarget(players, team, targetAvg) {
                    if (players.length === 0) return null;
                    if (players.length === 1) return players[0];
                    
                    let bestPlayer = players[0];
                    let bestDiff = Number.MAX_VALUE;
                    
                    for (const player of players) {
                        // Calcular a nova média se adicionarmos este jogador
                        const newAvg = (team.totalLevel + player.level) / (team.players.length + 1);
                        
                        // Calcular a diferença em relação ao alvo
                        const diff = Math.abs(newAvg - targetAvg);
                        
                        // Se este jogador produz uma média mais próxima do alvo
                        if (diff < bestDiff) {
                            bestPlayer = player;
                            bestDiff = diff;
                        }
                    }
                    
                    return bestPlayer;
                },
                
                // Display teams in the UI
                displayTeams(showNames = false) {
                    if (!this.drawnTeams || this.drawnTeams.length === 0) {
                        this.elements.drawResults.classList.add('hidden');
                        this.elements.noDrawResults.classList.remove('hidden');
                        this.elements.shareButtons.classList.add('hidden');
                        return;
                    }
                    
                    this.elements.teamsContainer.innerHTML = '';
                    this.elements.drawResults.classList.remove('hidden');
                    this.elements.noDrawResults.classList.add('hidden');
                    this.namesRevealed = showNames;
                    
                    // Get starting teams
                    const startingTeams = [...this.drawnTeams];
                    if (startingTeams.length > 2) {
                        startingTeams.sort(() => Math.random() - 0.5);
                        this.startingTeams = startingTeams.slice(0, 2);
                    } else {
                        this.startingTeams = [...startingTeams];
                    }
                    
                    // Display each team
                    this.drawnTeams.forEach((team, index) => {
                        const isStarting = this.startingTeams.includes(team);
                        const positions = ['ZAG', 'MEI', 'ATA'];
                        
                        const teamCard = document.createElement('div');
                        teamCard.className = `bg-white rounded-lg shadow-md overflow-hidden transition-all duration-300 ${isStarting ? 'border-2 border-green-500' : ''}`;
                        
                        // Calculate average level
                        const avgLevel = team.players.length > 0 
                            ? (team.totalLevel / team.players.length).toFixed(1) 
                            : '0.0';
                        
                        let headerColor = '';
                        if (index === 0) headerColor = 'bg-red-500 text-white';
                        else if (index === 1) headerColor = 'bg-blue-500 text-white';
                        else if (index === 2) headerColor = 'bg-green-500 text-white';
                        else if (index === 3) headerColor = 'bg-yellow-500 text-white';
                        
                        teamCard.innerHTML = `
                            <div class="p-4 ${headerColor} flex justify-between items-center">
                                <h3 class="text-lg font-bold">${team.name}</h3>
                                ${isStarting ? '<span class="bg-white text-green-600 px-2 py-1 rounded text-xs font-bold">Começa Jogando</span>' : ''}
                            </div>
                            <div class="p-4">
                                <div class="grid grid-cols-3 gap-3 mb-4">
                                    <div class="bg-gray-100 p-2 rounded text-center">
                                        <p class="text-gray-500 text-xs">Jogadores</p>
                                        <p class="text-xl font-bold">${team.players.length}</p>
                                    </div>
                                    <div class="bg-gray-100 p-2 rounded text-center">
                                        <p class="text-gray-500 text-xs">Nível Total</p>
                                        <p class="text-xl font-bold">${team.totalLevel.toFixed(1)}</p>
                                    </div>
                                    <div class="bg-gray-100 p-2 rounded text-center">
                                        <p class="text-gray-500 text-xs">Média</p>
                                        <p class="text-xl font-bold">${avgLevel}</p>
                                    </div>
                                </div>
                                
                                <div class="space-y-3">
                                    ${positions.map(pos => {
                                        const posPlayers = team.players.filter(p => p.position === pos);
                                        
                                        let positionClass = '';
                                        if (pos === 'ZAG') positionClass = 'bg-red-100 text-red-800';
                                        else if (pos === 'MEI') positionClass = 'bg-green-100 text-green-800';
                                        else if (pos === 'ATA') positionClass = 'bg-blue-100 text-blue-800';
                                        
                                        return `
                                            <div>
                                                <h4 class="text-sm font-medium mb-2">
                                                    <span class="inline-block px-2 py-1 rounded-full text-xs ${positionClass}">${pos}</span>
                                                    <span class="text-gray-500">(${posPlayers.length})</span>
                                                </h4>
                                                <ul class="space-y-2">
                                                    ${posPlayers.map(player => {
                                                        let playerDisplay = '';
                                                        
                                                        if (showNames) {
                                                            let nameDisplay = player.name;
                                                            const isStar = this.isPlayerStar(player.name);
                                                            const isWeak = this.isPlayerWeak(player.name);
                                                            
                                                            playerDisplay = `
                                                                <span class="font-medium">${nameDisplay}</span>
                                                                <span class="text-gray-500 ml-2">(${player.level})</span>
                                                                ${isStar ? '<span class="text-yellow-500 ml-1">⭐</span>' : ''}
                                                                ${isWeak ? '<i class="fas fa-arrow-down text-red-600 ml-1"></i>' : ''}
                                                            `;
                                                        } else {
                                                            playerDisplay = `
                                                                <span class="font-medium bg-gray-200 px-3 py-1 rounded-lg animate-pulse-slow">
                                                                    Jogador
                                                                </span>
                                                                <span class="text-gray-500 ml-2">(${player.level})</span>
                                                            `;
                                                        }
                                                        
                                                        return `<li class="bg-white p-2 rounded-lg border border-gray-100 shadow-sm">${playerDisplay}</li>`;
                                                    }).join('')}
                                                </ul>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                        
                        this.elements.teamsContainer.appendChild(teamCard);
                    });
                    
                    // Show or hide share buttons
                    if (showNames) {
                        this.elements.shareButtons.classList.remove('hidden');
                    } else {
                        this.elements.shareButtons.classList.add('hidden');
                    }
                },
                
                // Reveal player names
                revealPlayerNames() {
                    this.elements.acceptBalanceBtn.classList.add('hidden');
                    this.elements.tryAgainBtn.classList.add('hidden');
                    this.displayTeams(true);
                },
                
                // Format draw results for sharing
                formatDrawResultsForShare() {
                    if (!this.drawnTeams || this.drawnTeams.length === 0) {
                        return 'Nenhum sorteio realizado ainda.';
                    }
                    
                    // Get current date and format it
                    const today = new Date();
                    const dateStr = today.toLocaleDateString('pt-BR');
                    
                    let message = `*SORTEIO DE TIMES - ${dateStr}*\n\n`;
                    
                    this.drawnTeams.forEach((team, index) => {
                        const isStarting = this.startingTeams.includes(team);
                        
                        message += `*${team.name}* ${isStarting ? '(Começa jogando)' : ''}\n`;
                        message += `- Jogadores: ${team.players.length}\n`;
                        message += `- Nível Total: ${team.totalLevel.toFixed(1)}\n`;
                        message += `- Média Técnica: ${(team.totalLevel / team.players.length).toFixed(1)}\n\n`;
                        
                        const positions = [
                            { code: 'ZAG', symbol: '-' },
                            { code: 'MEI', symbol: '-' },
                            { code: 'ATA', symbol: '-' }
                        ];
                        
                        positions.forEach(pos => {
                            const posPlayers = team.players.filter(p => p.position === pos.code);
                            if (posPlayers.length > 0) {
                                message += `${pos.symbol} *${pos.code}:* `;
                                
                                // Display names with status indicators
                                const playerNames = posPlayers.map(player => {
                                    let name = player.name;
                                    if (this.isPlayerStar(player.name)) name += "";
                                    if (this.isPlayerWeak(player.name)) name += "";
                                    return name;
                                });
                                
                                message += playerNames.join(', ');
                                message += '\n';
                            }
                        });
                        
                        message += '\n';
                    });
                    
                    if (this.startingTeams.length === 2) {
                        message += `- *Começa Jogando:* `;
                        message += this.startingTeams.map(t => t.name).join(' vs ');
                        message += '\n\n';
                    }
                    
                    message += 'Sorteado no Pelada Manager';
                    
                    return message;
                },
                
                // Format players for sharing
                formatPlayersForShare() {
                    if (this.players.length === 0) {
                        return 'Nenhum jogador cadastrado ainda.';
                    }
                    
                    let message = '*LISTA DE JOGADORES*\n\n';
                    
                    const totalPlayers = this.players.length;
                    const availablePlayers = this.players.filter(p => p.available).length;
                    
                    message += `- Total de Jogadores: ${totalPlayers}\n`;
                    message += `- Disponíveis: ${availablePlayers}\n\n`;
                    
                    const positions = [
                        { code: 'ZAG', symbol: '-' },
                        { code: 'MEI', symbol: '-' },
                        { code: 'ATA', symbol: '-' }
                    ];
                    
                    positions.forEach(pos => {
                        const posPlayers = this.players.filter(p => p.position === pos.code);
                        if (posPlayers.length > 0) {
                            message += `${pos.symbol} *${pos.code} (${posPlayers.length}):*\n`;
                            
                            // Sort by name
                            const sortedPlayers = [...posPlayers].sort((a, b) => a.name.localeCompare(b.name));
                            
                            sortedPlayers.forEach(p => {
                                let name = p.name;
                                if (this.isPlayerStar(p.name)) name += ' ★';
                                if (this.isPlayerWeak(p.name)) name += ' ↓';
                                
                                message += `   ${name} (${p.level})`;
                                message += p.available ? ' ✓' : ' ✗';
                                message += '\n';
                            });
                            
                            message += '\n';
                        }
                    });
                    
                    message += 'Gerado no Pelada Manager';
                    
                    return message;
                },
                
                // Share via WhatsApp
                shareViaWhatsApp(message) {
                    const encodedMessage = encodeURIComponent(message);
                    window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');
                },
                
                // Switch tab
                switchTab(tabName) {
                    // Update tab buttons
                    this.elements.tabButtons.forEach(button => {
                        if (button.getAttribute('data-tab') === tabName) {
                            button.classList.add('border-primary', 'text-primary');
                            button.classList.remove('border-transparent', 'hover:text-primary');
                        } else {
                            button.classList.remove('border-primary', 'text-primary');
                            button.classList.add('border-transparent', 'hover:text-primary');
                        }
                    });
                    
                    // Update tab contents
                    this.elements.tabContents.forEach(content => {
                        if (content.id === `${tabName}-tab`) {
                            content.classList.remove('hidden');
                        } else {
                            content.classList.add('hidden');
                        }
                    });
                },
                
                // Show toast notification
                showToast(message, type = 'success') {
                    // Set icon and background color based on type
                    let iconClass = '';
                    let bgClass = '';
                    
                    if (type === 'success') {
                        iconClass = 'fa-check-circle text-green-400';
                        bgClass = 'bg-green-800';
                    } else if (type === 'error') {
                        iconClass = 'fa-exclamation-circle text-red-400';
                        bgClass = 'bg-red-800';
                    } else if (type === 'info') {
                        iconClass = 'fa-info-circle text-blue-400';
                        bgClass = 'bg-blue-800';
                    } else if (type === 'warning') {
                        iconClass = 'fa-exclamation-triangle text-yellow-400';
                        bgClass = 'bg-yellow-800';
                    }
                    
                    // Update toast content
                    this.elements.toastIcon.innerHTML = `<i class="fas ${iconClass}"></i>`;
                    this.elements.toastMessage.textContent = message;
                    this.elements.toast.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg ${bgClass} text-white transform transition-transform duration-300 flex items-center z-50`;
                    
                    // Show toast
                    setTimeout(() => {
                        this.elements.toast.classList.remove('translate-y-full');
                    }, 10);
                    
                    // Hide toast after 3 seconds
                    setTimeout(() => {
                        this.elements.toast.classList.add('translate-y-full');
                    }, 3000);
                },
                
                // Utility: Shuffle array
                shuffleArray(array) {
                    const newArray = [...array];
                    for (let i = newArray.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                    }
                    return newArray;
                },
                
                // Update UI
                updateUI() {
                    this.updatePlayerList();
                    this.updateTeamNamesInputs();
                    this.updateRestrictionsList();
                }
            };
            
            // Make app globally accessible for the event handlers
            window.app = app;
            
            // Initialize the app
            app.init();
        });
    </script>
</body>
</html>
